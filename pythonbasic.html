<html><head><meta content="text/html; charset=gb2312" http-equiv="Content-Type"><title>在线教程-Python基础篇</title><link rel="stylesheet" href="http://www.kuqin.com/docbook.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><meta name="description" content="现时国内python的中文资料极少，使学习Python较困难。国外的资料虽多，但都是英文的，使我们学习起来很不方便。有鉴于此，我开始了Python中文资料库的整理工作，以推动Python的发展和在中国的应用。在自由的世界里，正因为有你的支持和帮助，才使我得以不断前进。我相信我们每人一小步就可带动python在中国前进一大步。 "></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<a href="index.html"><< 返回在线教程 </a><br><br>

<div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="id2875165"></a>Python基础篇</h1></div><div><div class="author"><h3 class="author"><span class="firstname">整理：Jims of <a href="http://www.ringkee.com" target="_top">肥肥世家</a>
	</span></h3><div class="affiliation"><div class="address"><p><tt class="email">&lt;<a href="mailto:jims.yang@gmail.com">jims.yang@gmail.com</a>&gt;</tt></p></div></div></div></div><div><p class="copyright">Copyright &copy; 2004，2005，2006 本文遵从GNU 的自由文档许可证(Free Document License)的条款，欢迎转载、修改、散布。</p></div><div><p class="pubdate">发布时间：2004年07月10日</p></div><div><p class="pubdate">更新时间：2006年06月14日，把参考篇的内容合并进来。</p></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>现时国内python的中文资料极少，使学习Python较困难。国外的资料虽多，但都是英文的，使我们学习起来很不方便。有鉴于此，我开始了Python中文资料库的整理工作，以推动Python的发展和在中国的应用。在自由的世界里，正因为有你的支持和帮助，才使我得以不断前进。我相信我们每人一小步就可带动python在中国前进一大步。 </p></div></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="pythonbasic.html#id2875104">1. 绪论</a></span></dt><dd><dl><dt><span class="sect1"><a href="pythonbasic.html#id2811704">1.1. Python历史</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2811781">1.2. Python功能简介</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2810170">1.3. 应用范围</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2810267">1.4. 如何开始？</a></span></dt></dl></dd><dt><span class="chapter"><a href="pythonbasic.html#id2861425">2. Python编程习惯与特点</a></span></dt><dd><dl><dt><span class="sect1"><a href="pythonbasic.html#id2861433">2.1. 代码风格</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2861575">2.2. 保留字</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2861594">2.3. Python运算符和表达式</a></span></dt><dd><dl><dt><span class="sect2"><a href="pythonbasic.html#id2861602">2.3.1. Python运算符</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2861844">2.3.2. 运算符优先顺序</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2808594">2.3.3. 真值表</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2808746">2.3.4. 复合表达式</a></span></dt></dl></dd><dt><span class="sect1"><a href="pythonbasic.html#id2808820">2.4. 给变量赋值</a></span></dt></dl></dd><dt><span class="chapter"><a href="pythonbasic.html#id2808911">3. Python内建对象类型</a></span></dt><dd><dl><dt><span class="sect1"><a href="pythonbasic.html#id2808928">3.1. Number数值型</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2809008">3.2. String字符串型</a></span></dt><dd><dl><dt><span class="sect2"><a href="pythonbasic.html#id2809192">3.2.1. 字符串的格式化</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2809469">3.2.2. 转义字符</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2875369">3.2.3. Unicode字符串</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2875512">3.2.4. 原始字符串</a></span></dt></dl></dd><dt><span class="sect1"><a href="pythonbasic.html#id2875536">3.3. List列表</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2875904">3.4. Tuple元组</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2875979">3.5. 序列对象</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876078">3.6. Dictionary字典</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876321">3.7. File文件</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876343">3.8. 理解引用</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876409">3.9. copy and deepcopy</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876486">3.10. 标识数据类型</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876523">3.11. 数组对象</a></span></dt></dl></dd><dt><span class="chapter"><a href="pythonbasic.html#id2876868">4. 控制语句</a></span></dt><dt><span class="chapter"><a href="pythonbasic.html#id2877126">5. 函数</a></span></dt><dd><dl><dt><span class="sect1"><a href="pythonbasic.html#id2877464">5.1. 常用函数</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2877751">5.2. 内置类型转换函数</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2878060">5.3. 序列处理函数</a></span></dt></dl></dd><dt><span class="chapter"><a href="pythonbasic.html#id2878241">6. 模块</a></span></dt><dd><dl><dt><span class="sect1"><a href="pythonbasic.html#id2878430">6.1. String模块</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2878537">6.2. time模块</a></span></dt></dl></dd><dt><span class="chapter"><a href="pythonbasic.html#id2878619">7. 类</a></span></dt><dt><span class="chapter"><a href="pythonbasic.html#id2878694">8. 异常处理</a></span></dt><dt><span class="chapter"><a href="pythonbasic.html#id2878856">9. 文件处理</a></span></dt><dd><dl><dt><span class="sect1"><a href="pythonbasic.html#id2878871">9.1. 文件处理的函数和方法</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2879330">9.2. 示例</a></span></dt></dl></dd><dt><span class="chapter"><a href="pythonbasic.html#id2879657">10. 正则表达式</a></span></dt><dd><dl><dt><span class="sect1"><a href="pythonbasic.html#id2879700">10.1. 基本元素</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2880568">10.2. 操作</a></span></dt></dl></dd><dt><span class="chapter"><a href="pythonbasic.html#id2881059">11. 调试</a></span></dt><dt><span class="chapter"><a href="pythonbasic.html#id2881117">12. HOW-TO</a></span></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>1.1. <a href="pythonbasic.html#id2810362">Python命令行选项</a></dt><dt>2.1. <a href="pythonbasic.html#id2861610">Python运算符列表</a></dt><dt>2.2. <a href="pythonbasic.html#id2861851">运算符优先顺序列表(从最高到最低)</a></dt><dt>2.3. <a href="pythonbasic.html#id2808601"></a></dt><dt>3.1. <a href="pythonbasic.html#id2809205">字符串格式化代码</a></dt><dt>3.2. <a href="pythonbasic.html#id2809482">python支持的转义字符表</a></dt><dt>3.3. <a href="pythonbasic.html#id2875740">列表对象支持的方法</a></dt><dt>3.4. <a href="pythonbasic.html#id2876174">字典方法</a></dt><dt>3.5. <a href="pythonbasic.html#id2876537">数组类型代码</a></dt><dt>9.1. <a href="pythonbasic.html#id2878904">mode</a></dt><dt>9.2. <a href="pythonbasic.html#id2879035">bufsize</a></dt><dt>9.3. <a href="pythonbasic.html#id2879132">文件对象方法</a></dt><dt>10.1. <a href="pythonbasic.html#id2879712">正则表达式基本字符</a></dt><dt>10.2. <a href="pythonbasic.html#id2879806">匹配限定符</a></dt><dt>10.3. <a href="pythonbasic.html#id2879972">组和运算符</a></dt><dt>10.4. <a href="pythonbasic.html#id2880082">特殊字符序列</a></dt><dt>10.5. <a href="pythonbasic.html#id2880267">正则表达式声明</a></dt><dt>10.6. <a href="pythonbasic.html#id2880446">处理标志</a></dt><dt>10.7. <a href="pythonbasic.html#id2880594">MatchObject对象方法</a></dt><dt>10.8. <a href="pythonbasic.html#id2880883">正则式对象方法/属性</a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2875104"></a>Chapter 1. 绪论</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="pythonbasic.html#id2811704">1.1. Python历史</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2811781">1.2. Python功能简介</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2810170">1.3. 应用范围</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2810267">1.4. 如何开始？</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2811704"></a>1.1. Python历史</h2></div></div><div></div></div><p>Python是一种开源的面向对象的脚本语言，它起源于1989年末，当时，CWI（阿姆斯特丹国家数学和计算机科学研究所）的研究员Guido van Rossum需要一种高级脚本编程语言，为其研究小组的Amoeba分布式操作系统执行管理任务。为创建新语言，他从高级数学语言ABC（ALL BASIC CODE）汲取了大量语法，并从系统编程语言Modula-3借鉴了错语处理机制。Van Rossum把这种新的语言命名为Python（大蟒蛇）---来源于BBC当时正在热播的喜剧连续剧“Monty Python”。</p><p>Python于1991年初公开发行，由于功能强大和采用开源方式发行，Python的发展得很快，用户越来越多，形成了一个强大的社区力量。2001年，Python的核心开发团队移师Digital Creations公司，该公司是Zope（一个用Python编写的web应用服务器）的创始者。现在最新的版本是python2.3.4，大家可到<a href="http://www.python.org" target="_top">http://www.python.org</a>上了解最新的Python动态和资料 。</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2811781"></a>1.2. Python功能简介</h2></div></div><div></div></div><p>Python是一种解析性的，交互式的，面向对象的编程语言，类似于Perl、Tcl、Scheme或Java。</p><p>Python一些主要功能介绍:</p><div class="itemizedlist"><ul type="disc"><li><p>Python使用一种优雅的语法，可读性强。</p></li><li><p>Python是一种很灵活的语言，能帮你轻松完成编程工作。并可作为一种原型开发语言，加快大型程序的开发速度。</p></li><li><p>有多种数据类型：numbers (integers, floating point, complex, and unlimited-length long integers), strings (ASCII 和 Unicode), lists, dictionaries。</p></li><li><p>Python支持类和多层继承等的面向对象编程技术。</p></li><li><p>代码能打包成模块和包，方便管理和发布。</p></li><li><p>支持异常处理，能有效捕获和处理程序中发生的错误。</p></li><li><p>强大的动态数据类型支持，不同数据类型相加会引发一个异常。</p></li><li><p>Python支持如生成器和列表嵌套等高级编程功能。</p></li><li><p>自动内存碎片管理，有效利用内存资源。</p></li><li><p>强大的类库支持，使编写文件处理、正则表达式，网络连接等程序变得相当容易。</p></li><li><p>Python的交互命令行模块能方便地进行小代码调试和学习。</p></li><li><p>Python易于扩展，可以通过C或C++编写的模块进行功能扩展。</p></li><li><p>Python解析器可作为一个编程接口嵌入一个应用程序中。</p></li><li><p>Python可运行在多种计算机平台和操作系统中，如各位unix，windows，MacOS,OS/2等等。</p></li><li><p>Python是开源的，可自由免费使用和发布，并且可用于商业用途以获取利润。如想详细了解Python的许可协议可到以下网址查询<a href="http://www.python.org/psf/license.html" target="_top">http://www.python.org/psf/license.html</a>
						</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2810170"></a>1.3. 应用范围</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>系统编程，提供大量系统接口API，能方便进行系统维护和管理。</p></li><li><p>图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。</p></li><li><p>数学处理，NumPy扩展提供大量与许多标准数学库的接口，</p></li><li><p>文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。</p></li><li><p>数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql等数据库通信。python自带有一个Gadfly模块，提供了一个完整的SQL环境。</p></li><li><p>网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。</p></li><li><p>作为Web应用的开发语言，支持最新的XML技术。</p></li><li><p>多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2810267"></a>1.4. 如何开始？</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>进入交互命令行方式。如果是linux类的系统，python解析器应该已经安装在/usr/local/bin/python中，直接打python就可进入交互式命令行界面，如下所示:
</p><pre class="screen">
Python 2.3.3 (#1, Apr 27 2004, 15:17:58) 
[GCC 3.2 20020903 (Red Hat Linux 8.0 3.2-7)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; 
</pre><p>
“&gt;&gt;&gt;”符号是Python命令行界面的提示符，可按CTRL+D退出，如果是windows环境的话就要按CTRL+Z了。还可以用以下命令退出命令行界面：“import sys；sys.exit()”。如果是windows系统，可到<a href="http://www.python.org/download/" target="_top">http://www.python.org/download/</a>下载最新的安装程序进行安装。安装完成后直接打python也可进入命令行界面。命令行是python最简单直观，也是最方便的一种执行环境，我们可以在这里学习python语法和调试程序。如果要打印&quot;hello world&quot;可以输入以下命令：
</p><pre class="screen">
&gt;&gt;&gt;print &quot;hello world&quot;
hello world
</pre><p>
						</p></li><li><p>以模块文件方式运行。模块文件是包含python语句的文本，以.py结尾。运行模块文件只要输入python xxx.py就可以了。</p></li><li><p>以linux脚本方式运行。和shell脚本差不多，以vi或其它文本编辑器输入以下内容:
</p><pre class="screen">
#!/usr/local/bin/python
print &quot;test ............&quot;
</pre><p>
存盘后，把文件属性改为可执行，就可象shell脚本一样执行了。</p></li><li><div class="table"><a name="id2810362"></a><p class="title"><b>Table 1.1. Python命令行选项</b></p><table summary="Python命令行选项" border="1"><colgroup><col><col></colgroup><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-c cmd</td><td>在命令行直接执行python代码。如python -c 'print &quot;hello world&quot;'。</td></tr><tr><td>-d</td><td>脚本编译后从解释器产生调试信息。同PYTHONDEBUG=1。</td></tr><tr><td>-E</td><td>忽略环境变量。</td></tr><tr><td>-h</td><td>显示python命令行选项帮助信息。</td></tr><tr><td>-i</td><td>脚本执行后马上进入交互命令行模式。同PYTHONINSPECT=1。</td></tr><tr><td>-O</td><td>在执行前对解释器产生的字节码进行优化。同 PYTHONOPTIMIZE=1。</td></tr><tr><td>-OO</td><td>在执行前对解释器产生的字节码进行优化，并删除优化代码中的嵌入式文档字符串。</td></tr><tr><td>-Q arg</td><td>除法规则选项，-Qold(default)，-Qwarn，-Qwarnall，-Qnew。 </td></tr><tr><td>-S</td><td>解释器不自动导入site.py模块。</td></tr><tr><td>-t</td><td>当脚本的tab缩排格式不一致时产生警告。</td></tr><tr><td>-u</td><td>不缓冲stdin、stdout和stderr，默认是缓冲的。同PYTHONUNBUFFERED=1。</td></tr><tr><td>-v</td><td>产生每个模块的信息。如果两个-v选项，则产生更详细的信息。同PYTHONVERBOSE=x。</td></tr><tr><td>-V</td><td>显示Python的版本信息。</td></tr><tr><td>-W arg</td><td>出错信息控制。(arg is action:message:category:module:lineno)</td></tr><tr><td>-x</td><td>忽略源文件的首行。要在多平台上执行脚本时有用。</td></tr><tr><td>file</td><td>执行file里的代码。</td></tr><tr><td>-</td><td>从stdin里读取执行代码。</td></tr></tbody></table></div></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2861425"></a>Chapter 2. Python编程习惯与特点</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="pythonbasic.html#id2861433">2.1. 代码风格</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2861575">2.2. 保留字</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2861594">2.3. Python运算符和表达式</a></span></dt><dd><dl><dt><span class="sect2"><a href="pythonbasic.html#id2861602">2.3.1. Python运算符</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2861844">2.3.2. 运算符优先顺序</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2808594">2.3.3. 真值表</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2808746">2.3.4. 复合表达式</a></span></dt></dl></dd><dt><span class="sect1"><a href="pythonbasic.html#id2808820">2.4. 给变量赋值</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2861433"></a>2.1. 代码风格</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>在Python中，每行程序以换行符代表结束，如果一行程序太长的话，可以用“\”符号扩展到下一行。在python中以三引号(&quot;&quot;&quot;)括起来的字符串，列表，元组和字典都能跨行使用。并且以小括号(...)、中括号[...]和大括号{...}包围的代码不用加“\”符也可扩展到多行。如：</p></li><li><p>在Python中是以缩进来区分程序功能块的，缩进的长度不受限制，但就一个功能块来讲，最好保持一致的缩进量。</p></li><li><p>如果一行中有多条语句，语句间要以分号（;）分隔。</p></li><li><p>以“#”号开头的内容为注释，python解释器会忽略该行内容。</p></li><li><p>在python中，所有标识符可以包括英文、数字以及下划线（_），但不能以数字开头。python中的标识符是区分大小写的。</p></li><li><p>以下划线开头的标识符是有特殊意义的。以单下划线开头（_foo）的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用“from xxx import *”而导入；以双下划线开头的（__foo）代表类的私有成员；以双下划线开头和结尾的（__foo__）代表python里特殊方法专用的标识，如__init__（）代表类的构造函数。</p></li><li><p>在交互模式下运行python时，一个下划线字符(_)是特殊标识符，它保留了表达式的最后一个计算结果。</p><pre class="screen">
&gt;&gt;&gt; &quot;hello&quot;
'hello'
&gt;&gt;&gt; _
'hello'
&gt;&gt;&gt; 10+10
20
&gt;&gt;&gt; _
20

</pre></li><li><p>在python中，函数、类、模块定义的第一段代码如果是字符串的话，就把它叫作文件字串，可通过__doc__属性访问。如:</p><pre class="screen">
def test():
&quot;this is a document string&quot;

return 100+1000

&gt;&gt;&gt;print test.__doc__
this is a document string
</pre></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2861575"></a>2.2. 保留字</h2></div></div><div></div></div><pre class="screen">
	and		elif		global		or          yield
	assert		else		if		pass
	break		except		import		print
	class		exec		in		raise
	continue	finally		is		return
	def		for		lambda		try
	del		from		not		while
				</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2861594"></a>2.3. Python运算符和表达式</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2861602"></a>2.3.1. Python运算符</h3></div></div><div></div></div><div class="table"><a name="id2861610"></a><p class="title"><b>Table 2.1. Python运算符列表</b></p><table summary="Python运算符列表" border="1"><colgroup><col><col></colgroup><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>x+y，x-y</td><td>加、减，“+”号可重载为连接符</td></tr><tr><td>x*y，x**y，x/y，x%y</td><td>相乘、求平方、相除、求余，“*”号可重载为重复，“%”号可重载为格式化</td></tr><tr><td>&lt;，&lt;=，&gt;，&gt;=，==，&lt;&gt;，!=</td><td>比较运算符</td></tr><tr><td>+=，-=，*=，/=，%=，**=，&lt;&lt;=，&gt;&gt;=，&amp;=，^=，|=</td><td>自变运算符</td></tr><tr><td>x|y</td><td>按位或</td></tr><tr><td>x^y</td><td>按位异或</td></tr><tr><td>x&amp;y</td><td>按位与</td></tr><tr><td>~x</td><td>按位取反</td></tr><tr><td>x&lt;&lt;，x&gt;&gt;y</td><td>x向左或向右移y位</td></tr><tr><td>is, is not</td><td>等同测试</td></tr><tr><td>in, not in</td><td>是否为成员测试</td></tr><tr><td>or，and，not</td><td>逻辑运算符</td></tr><tr><td>x[i]，x[i:j]，x.y，x(...)</td><td>索引，分片，限定引用，函数调用</td></tr><tr><td>(...)，[...]，{...}，'...'</td><td>元组，列表，字典，转化为字符串</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2861844"></a>2.3.2. 运算符优先顺序</h3></div></div><div></div></div><div class="table"><a name="id2861851"></a><p class="title"><b>Table 2.2. 运算符优先顺序列表(从最高到最低)</b></p><table summary="运算符优先顺序列表(从最高到最低)" border="1"><colgroup><col><col></colgroup><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>'expr'</td><td>字符串转换</td></tr><tr><td>{key:expr,...}</td><td>字典</td></tr><tr><td>[expr1,expr2...]</td><td>列表</td></tr><tr><td>(expr1,expr2,...)</td><td>元组</td></tr><tr><td>function(expr,...)</td><td>函数调用</td></tr><tr><td>x[index:index]</td><td>切片</td></tr><tr><td>x[index]</td><td>下标索引取值</td></tr><tr><td>x.attribute</td><td>属性引用</td></tr><tr><td>~x</td><td>按位取反</td></tr><tr><td>+x，-x</td><td>正，负</td></tr><tr><td>x**y</td><td>幂</td></tr><tr><td>x*y，x/y，x%y</td><td>乘，除，取模</td></tr><tr><td>x+y，x-y</td><td>加，减</td></tr><tr><td>x&lt;&lt;y，x&gt;&gt;y</td><td>移位</td></tr><tr><td>x&amp;y</td><td>按位与</td></tr><tr><td>x^y</td><td>按位异或</td></tr><tr><td>x|y</td><td>按位或</td></tr><tr><td>x&lt;y，x&lt;=y，x==y，x!=y，x&gt;=y，x&gt;y</td><td>比较</td></tr><tr><td>x is y，x is not y</td><td>等同测试</td></tr><tr><td>x in y，x not in y</td><td>成员判断</td></tr><tr><td>not x</td><td>逻辑否</td></tr><tr><td>x and y</td><td>逻辑与</td></tr><tr><td>x or y</td><td>逻辑或</td></tr><tr><td>lambda arg,...:expr</td><td>Lambda匿名函数</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2808594"></a>2.3.3. 真值表</h3></div></div><div></div></div><div class="table"><a name="id2808601"></a><p class="title"><b>Table 2.3. </b></p><table border="1"><colgroup><col><col></colgroup><thead><tr><th>对象/常量</th><th>值</th></tr></thead><tbody><tr><td>&quot;&quot;</td><td>假</td></tr><tr><td>&quot;string&quot;</td><td>真</td></tr><tr><td>0</td><td>假</td></tr><tr><td>&gt;=1</td><td>真</td></tr><tr><td>&lt;=-1</td><td>真</td></tr><tr><td>()空元组</td><td>假</td></tr><tr><td>[]空列表</td><td>假</td></tr><tr><td>{}空字典</td><td>假</td></tr><tr><td>None</td><td>假</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2808746"></a>2.3.4. 复合表达式</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>对于and，当计算a and b时，python会计算a，如果a为假，则取a值，如果a为真，则python会计算b且整个表达式会取b值。如：</p><pre class="screen">
&gt;&gt;&gt; a,b=10,20
&gt;&gt;&gt; a and b   #a is true
20
&gt;&gt;&gt; a,b=0,5   #a is false
&gt;&gt;&gt; a and b
0
</pre></li><li><p>对于or，当计算a or b时，python会计算a，如果a为真，则整个表达式取a值，如果a为假，表达式将取b值。如：</p><pre class="screen">
&gt;&gt;&gt; a,b=10,20
&gt;&gt;&gt; a or b
10
&gt;&gt;&gt; a,b=0,5
&gt;&gt;&gt; a or b
5
</pre></li><li><p>对于not，not将反转表表达式的“实际值”，如果表达式为真，not为返回假，如为表达式为假，not为返回真。如：</p><pre class="screen">
&gt;&gt;&gt; not 2
False
&gt;&gt;&gt; not 0
True
&gt;&gt;&gt; not &quot;test&quot;
False
&gt;&gt;&gt; not &quot;&quot;
True
</pre></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2808820"></a>2.4. 给变量赋值</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>简单赋值，Variable(变量)=Value(值)。</p><pre class="screen">
&gt;&gt;&gt;a=1
&gt;&gt;&gt;b=2
&gt;&gt;&gt;print a,b
1 2
</pre></li><li><p>多变量赋值，Variable1,variable2,...=Value1,Value2,...</p><pre class="screen">
&gt;&gt;&gt;a,b,c=1,2,3
&gt;&gt;&gt;print a
1
&gt;&gt;&gt;print b
2
&gt;&gt;&gt;print c
3
</pre><p>多变量赋值也可用于变量交换，接上例：</p><pre class="screen">
&gt;&gt;&gt;a,b,c=c,b,a
&gt;&gt;&gt;print a
3
&gt;&gt;&gt;print b
2
&gt;&gt;&gt;print c
1
</pre></li><li><p>多目标赋值，a=b=variable</p><pre class="screen">
&gt;&gt;&gt; a=b=1
&gt;&gt;&gt; a
1
&gt;&gt;&gt; b
1
&gt;&gt;&gt; a=2
&gt;&gt;&gt; a
2
&gt;&gt;&gt; b
1
</pre></li><li><p>自变赋值，如+=，-=，*=等。在自变赋值中，python仅计算一次，而普通写法需计算两次；自变赋值会修改原始对象，而不是创建一个新对象。</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2808911"></a>Chapter 3. Python内建对象类型</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="pythonbasic.html#id2808928">3.1. Number数值型</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2809008">3.2. String字符串型</a></span></dt><dd><dl><dt><span class="sect2"><a href="pythonbasic.html#id2809192">3.2.1. 字符串的格式化</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2809469">3.2.2. 转义字符</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2875369">3.2.3. Unicode字符串</a></span></dt><dt><span class="sect2"><a href="pythonbasic.html#id2875512">3.2.4. 原始字符串</a></span></dt></dl></dd><dt><span class="sect1"><a href="pythonbasic.html#id2875536">3.3. List列表</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2875904">3.4. Tuple元组</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2875979">3.5. 序列对象</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876078">3.6. Dictionary字典</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876321">3.7. File文件</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876343">3.8. 理解引用</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876409">3.9. copy and deepcopy</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876486">3.10. 标识数据类型</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2876523">3.11. 数组对象</a></span></dt></dl></div><p>在Python中，所有数据都是对象，数据有各种类型，如数值型、列表型、字符串型等。除系统内建的数据类型外，程序员也可以创建自已的数据类型。以下主要介绍Python内建的数据类型。</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2808928"></a>3.1. Number数值型</h2></div></div><div></div></div><p>在python中，数值有四种类型，分别是整型、长整形、浮点型和复数。</p><div class="itemizedlist"><ul type="disc"><li><p>整型---从-2147483648至2147483647，有符号位32位长，可表达的最大数为2^31-1。如：number=123，number1=-123。在数字前加0x或0X 前缀表示十六进制数，在数字前加前缀0表示八进制数，与C/C++ and perl一样。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://www.kuqin.com/docs/images/note.png"></td><th align="left"></th></tr><tr><td colspan="2" align="left" valign="top">为方便起见，sys模块包含一个maxint成员，该成员保留了整形变量的最大正数值。</td></tr></table></div><pre class="screen">
&gt;&gt;&gt; import sys
&gt;&gt;&gt; print sys.maxint
2147483647
</pre></li><li><p>长整型---python支持任意长度的长整型，长整型的最大值和最小值由可用的内存确定。长整型数在数字常量尾加L or l，一般都是用L，因为小写的l太容易与数字1混淆了。如：long=1232132131231232132132131L。</p></li><li><p>浮点数---python支持普通十进制和科学计数法表示的浮点数。如：number=123.456，nubmer1=123.2E10。浮点数在python中的存储格式与C中的双精度数相同。</p></li><li><p>复数---复数的实部和虚部用加号分开，虚部使用后缀j表示，如：number=1.2+2j</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2809008"></a>3.2. String字符串型</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>字符串在python被看成是单个字符的序列，具有序列对象的特殊功能，字符串是固定的，不可变的。如：string=&quot;hello world&quot;。</p></li><li><p>可在字符串中使用单引号和双引号。如：string=&quot;I'm a boy&quot;。</p></li><li><p>字符串内部的一个反斜杠“\”可允许把字符串放于多行：如：</p><pre class="screen">
&gt;&gt;&gt; &quot;test \
... python&quot;
'test python'</pre></li><li><p>使用三个单引号或双引号可使字符串跨行显示。如：
</p><pre class="screen">
helptext=&quot;&quot;&quot;this a help test.if you have any quesions.
            please call me anytime.I will help you.I
            like python.I hope so as you.&quot;&quot;&quot;
</pre></li><li><p>使用“+”号可连接字符串。如：string = &quot;hello&quot; + &quot;world&quot;，注意，不能将字符串与其它对象进行连接。如string = &quot;ok&quot; + 5。其实不用“+”号，直接用空格也可连接两个字符串。如：string=&quot;hello&quot; &quot;world&quot;。</p></li><li><p>可用“*”号重复字符串，如：'hello'*5会生成'hellohellohellohellohello'。</p></li><li><p>可用索引访问字符串中的字符。如：string=&quot;hello world&quot;，print string[1]将显示字符e。</p></li><li><p>字符串可用in或not in运算符来测试字符是不属于一个字符串的成员。</p></li><li><p>可对字符串分片，如string=&quot;hello world&quot;,print string[6:]将显示world。分片的格式为：</p><pre class="screen">
             string[start:end]
</pre><p>分片和索引的规则如下：</p><div class="itemizedlist"><ul type="circle"><li><p>返回的字符串包含从start起始到end但不包括end结束的所有字符。</p></li><li><p>若指定了start但未指定end，则一直向后分片，直至字符串结束。</p></li><li><p>若指定了end但未指定start，则从0开始分片直至end，但不包括end指定的字符。</p></li><li><p>若start和end为负数，则索引从字符串尾部开始算起，最后一个字符为-1。</p></li></ul></div></li></ul></div><p>python提供了一个string模块来进行字符串处理。</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2809192"></a>3.2.1. 字符串的格式化</h3></div></div><div></div></div><p>象C 中的sprintf函数一样，可以用“%”来格式化字符串。</p><div class="table"><a name="id2809205"></a><p class="title"><b>Table 3.1. 字符串格式化代码</b></p><table summary="字符串格式化代码" border="1"><colgroup><col><col></colgroup><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%%</td><td>百分号标记</td></tr><tr><td>%c</td><td>字符及其ASCII码</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%d</td><td>有符号整数(十进制)</td></tr><tr><td>%u</td><td>无符号整数(十进制)</td></tr><tr><td>%o</td><td>无符号整数(八进制)</td></tr><tr><td>%x</td><td>无符号整数(十六进制)</td></tr><tr><td>%X</td><td>无符号整数(十六进制大写字符)</td></tr><tr><td>%e</td><td>浮点数字(科学计数法)</td></tr><tr><td>%E</td><td>浮点数字(科学计数法，用E代替e)</td></tr><tr><td>%f</td><td>浮点数字(用小数点符号)</td></tr><tr><td>%g</td><td>浮点数字(根据值的大小采用%e或%f)</td></tr><tr><td>%G</td><td>浮点数字(类似于%g)</td></tr><tr><td>%p</td><td>指针(用十六进制打印值的内存地址)</td></tr><tr><td>%n</td><td>存储输出字符的数量放进参数列表的下一个变量中</td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://www.kuqin.com/docs/images/note.png"></td><th align="left"></th></tr><tr><td colspan="2" align="left" valign="top"><p>%格式化符也可用于字典，可用%(name)引用字典中的元素进行格式化输出。</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://www.kuqin.com/docs/images/note.png"></td><th align="left"></th></tr><tr><td colspan="2" align="left" valign="top"><p>负号指时数字应该是左对齐的，“0”告诉Python用前导0填充数字，正号指时数字总是显示它的正负(+，-)符号，即使数字是正数也不例外。</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://www.kuqin.com/docs/images/note.png"></td><th align="left"></th></tr><tr><td colspan="2" align="left" valign="top"><p>可指定最小的字段宽度，如：&quot;%5d&quot; % 2。也可用句点符指定附加的精度，如：&quot;%.3d&quot; % 3。</p></td></tr></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2809469"></a>3.2.2. 转义字符</h3></div></div><div></div></div><p>在需要在字符中使用特殊字符时，python用反斜杠(\)转义字符。如下表：</p><div class="table"><a name="id2809482"></a><p class="title"><b>Table 3.2. python支持的转义字符表</b></p><table summary="python支持的转义字符表" border="1"><colgroup><col><col></colgroup><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>\(在行尾时)</td><td>续行符</td></tr><tr><td>\\</td><td>反斜杠符号</td></tr><tr><td>\'</td><td>单引号</td></tr><tr><td>\&quot;</td><td>双引号</td></tr><tr><td>\a</td><td>响铃</td></tr><tr><td>\b</td><td>退格(Backspace)</td></tr><tr><td>\e</td><td>转义</td></tr><tr><td>\000</td><td>空</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\v</td><td>纵向制表符</td></tr><tr><td>\t</td><td>横向制表符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\oyy</td><td>八进制数yy代表的字符，例如：\o12代表换行</td></tr><tr><td>\xyy</td><td>十进制数yy代表的字符，例如：\x0a代表换行</td></tr><tr><td>\other</td><td>其它的字符以普通格式输出</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2875369"></a>3.2.3. Unicode字符串</h3></div></div><div></div></div><p>在python2.0中才完全支持Unicode字符串，Unicode字符采用16位(0---65535)值表示，能进行多语言支持。要使用Unicode字符串，只要在字符串前加上“u”即可。如：</p><pre class="screen">
&gt;&gt;&gt; a=u&quot;test&quot;
&gt;&gt;&gt; print a
test
</pre><p>原始Unicode字符串用ur前缀，如：</p><pre class="screen">
&gt;&gt;&gt; u'hello world\0020' 
u'hello world\x020'
&gt;&gt;&gt; ur'hello world\0020'
u'hello world\\0020'
</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2875406"></a>3.2.3.1. Unicode转换</h4></div></div><div></div></div><p>只要和Unicode连接，就会产生Unicode字串。如：</p><pre class="screen">
&gt;&gt;&gt; 'help'
'help'
&gt;&gt;&gt; 'help，' + u'python'     
u'help，python'
</pre><p>对于ASCII(7位)兼容的字串，可和内置的str()函数把Unicode字串转换成ASCII字串。如：</p><pre class="screen">
&gt;&gt;&gt; str(u'hello world')
'hello world'
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://www.kuqin.com/docs/images/note.png"></td><th align="left"></th></tr><tr><td colspan="2" align="left" valign="top">转换非ASCII兼容的字串会出错。编码和译码字符串时的错误引发UnicodeError异常。</td></tr></table></div><p>可使用encode()函数转换Unicode字串格式：</p><pre class="screen">
u'unicode\xb1\xe0\xc2\xeb\xb2\xe2\xca\xd4'
&gt;&gt;&gt; a.encode('utf-8')   #转换成utf-8，显示结果会根据终端的字符集支持不同而不同，下面是在GB18030下的显示结果
'unicode\xc2\xb1\xc3\xa0\xc3\x82\xc3\xab\xc2\xb2\xc3\xa2\xc3\x8a\xc3\x94'     
</pre><p>可使用unicode()函数把字符串转换成unicode格式，如：</p><pre class="screen">
&gt;&gt;&gt; a=u'unicode测试'
&gt;&gt;&gt; a
u'unicode\xb2\xe2\xca\xd4'
&gt;&gt;&gt; a.encode('utf-8')     #把unicode字串转换成utf-8
'unicode\xc2\xb2\xc3\xa2\xc3\x8a\xc3\x94'
&gt;&gt;&gt; b=a.encode('utf-8')   #给变量b赋值
&gt;&gt;&gt; b
'unicode\xc2\xb2\xc3\xa2\xc3\x8a\xc3\x94'
&gt;&gt;&gt;unicode(b,'utf-8')           #用unicode()函数把utf-8格式字串转换回unicode格式。
u'unicode\xb2\xe2\xca\xd4'      #和原始的这是a相同           
</pre><p>ord()支持unicode，可以显示特定字符的unicode号码，如：</p><pre class="screen">
&gt;&gt;&gt;ord('A')
65
</pre><p>使用unichr()函数可将unicode号码转换回unicode字符，如：</p><pre class="screen">
&gt;&gt;&gt; unichr(65)
u'A'
</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2875512"></a>3.2.4. 原始字符串</h3></div></div><div></div></div><p>有时我们并不想让转义字符生效，我们只想显示字符串原来的意思，这就要用r和R来定义原始字符串。如：</p><p>print r'\t\r'</p><p>实际输出为“\t\r”。</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2875536"></a>3.3. List列表</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>列表是序列对象，可包含任意的Python数据信息，如字符串、数字、列表、元组等。列表的数据是可变的，我们可通过对象方法对列表中的数据进行增加、修改、删除等操作。可以通过list(seq)函数把一个序列类型转换成一个列表。列表的几个例子：</p><div class="itemizedlist"><ul type="circle"><li><p>list = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]，这是字符列表。</p></li><li><p>list = [ 1, 2, 3, 4 ]，这是数字列表。</p></li><li><p>list = [ [1,2,3,4], [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] ]，这是列表的列表。</p></li><li><p>list = [ (1,2,3,4), (&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) ]，这是元组列表。</p></li><li><p>list((1,2))把一个元组转换成一个列表[1,2]，list('test')可把字符串转换成['t','e','s','t']列表。</p></li></ul></div></li><li><p>访问列表可通过索引来引用，如：list[0]将引用列表的第一个值。list[0:1]返回第一和第二个元素。</p></li><li><p>用range()和xrange()函数可自动生成列表，具体用法请参考“python参考篇”的内容。</p></li><li><p>可通过列表综合来创建列表，该功能是在python2.0版本中新增加的。如果想对列表中的每个项进行运算并把结果存储在一个新列表中，可者想创建一个仅包含特定满足某种条件的项，采用该方法是很适合的。如：[x*x for x in range(1,10)]会得到一个X的平方的新列表；我们还可添加if条件控制输出，如：[x*x for x in range(1,10) if x%2==0]；还可在列表中使用多个for语句，如：</p><pre class="screen">
&gt;&gt;&gt; [x+y for x in &quot;123&quot; for y in &quot;abc&quot;]
['1a', '1b', '1c', '2a', '2b', '2c', '3a', '3b', '3c']
</pre><p>x,y值可取列表或元组等，以构成更复杂的结构。</p></li><li><p>“+”号可连接两个列表。</p></li><li><p>访问列表的列表(嵌套列表)可用list[1][0]，这将访问嵌套中的第二个列表的第一个元素。</p></li><li><p>可用数字与列表相乘以复制内容，如：list*2会得到一个[1,2,3,4,1,2,3,4]的列表。注意，不能用列表与列表相乘。</p></li><li><p>由于列表是可变的，我们可用赋值语句进行操作，如：list[0] = 2。</p></li><li><p>列表对象方法可对列表进行操作，如列表内容的添加，删除，排序等。如list.sort()可对list列表进行排序。</p><div class="table"><a name="id2875740"></a><p class="title"><b>Table 3.3. 列表对象支持的方法</b></p><table summary="列表对象支持的方法" border="1"><colgroup><col><col></colgroup><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>append(x)</td><td>在列表尾部追加单个对象x。使用多个参数会引起异常。</td></tr><tr><td>count(x)</td><td>返回对象x在列表中出现的次数。</td></tr><tr><td>extend(L)</td><td>将列表L中的表项添加到列表中。返回None。</td></tr><tr><td>Index(x)</td><td>返回列表中匹配对象x的第一个列表项的索引。无匹配元素时产生异常。</td></tr><tr><td>insert(i,x)</td><td>在索引为i的元素前插入对象x。如list.insert(0,x)在第一项前插入对象。返回None。</td></tr><tr><td>pop(x)</td><td>删除列表中索引为x的表项，并返回该表项的值。若未指定索引，pop返回列表最后一项。</td></tr><tr><td>remove(x)</td><td>删除列表中匹配对象x的第一个元素。匹配元素时产生异常。返回None。</td></tr><tr><td>reverse()</td><td>颠倒列表元素的顺序。</td></tr><tr><td>sort()</td><td>对列表排序，返回none。bisect模块可用于排序列表项的添加和删除。</td></tr></tbody></table></div></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2875904"></a>3.4. Tuple元组</h2></div></div><div></div></div><p>Tuple(元组)和List(列表)很相似，但元组是不可变的。不能对元组中的元素进行添加，修改和删除操作。如果需修改元组内容只有重建元组。元组用小括号来表示。如tuple=(1,2,3)。</p><div class="itemizedlist"><ul type="disc"><li><p>tuple=(1,)，这是单个元素的元组表示，需加额外的逗号。</p></li><li><p>tuple=1，2，3，4，这也可以是一个元组，在不使用圆括号而不会导致混淆时，Python允许不使用圆括号的元组。</p></li><li><p>和列表一样，可对元组进行索引、分片、连接和重复。也可用len()求元组长度。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://www.kuqin.com/docs/images/note.png"></td><th align="left"></th></tr><tr><td colspan="2" align="left" valign="top">元组的索引用tuple[i]的形式，而不是tuple(i)。</td></tr></table></div></li><li><p>和列表类似，使用tuple(seq)可把其它序列类型转换成元组。</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2875979"></a>3.5. 序列对象</h2></div></div><div></div></div><p>上面介绍的字符串、列表和元组的对象类型均属于称为序列的Python对象。它是一种可使用数字化索引进行访问其中元素的对象。</p><div class="itemizedlist"><ul type="disc"><li><p>可用算术运算符联接或重复序列。</p></li><li><p>比较运算符(&lt;，&lt;=，&gt;，&gt;=，!=，==)也可用于序列。</p></li><li><p>可通过下标(test[1])，切片(test[1:3])和解包来访问序列的某部份。解包示例如下：</p><pre class="screen">
&gt;&gt;&gt;s=1,2,3 
&gt;&gt;&gt;x,y,z=s 
&gt;&gt;&gt;print x,y,z
1,2,3</pre></li><li><p>in运算符可判断当有对象是否序列对象成员，如:</p><pre class="screen">
&gt;&gt;&gt;list = [1,2,3]
&gt;&gt;&gt;1 in list
1
&gt;&gt;&gt;4 in list
0
</pre></li><li><p>也可通过循环运算符对序列对象进行迭代操作。如:</p><pre class="screen">
for day in days:
    print day
</pre></li></ul></div><p>有关序列的处理函数请参考“python参考篇”相关内容，这里就不详细讲了。</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2876078"></a>3.6. Dictionary字典</h2></div></div><div></div></div><p>字典是一个用大括号括起来的键值对，字典元素分为两部份，键(key)和值。字典是python中唯一内置映射数据类型。通过指定的键从字典访问值。如：</p><pre class="screen">
monthdays = { &quot;Jan&quot;:31, &quot;Feb&quot;:28, &quot;Mar&quot;:31, &quot;Apr&quot;:30, &quot;May&quot;:31, &quot;Jun&quot;:30, &quot;Jul&quot;:31, &quot;Aug&quot;:31, &quot;Sep&quot;:30, &quot;Oct&quot;:31, &quot;Nov&quot;:30,&quot;Dec&quot;:31 }
</pre><div class="itemizedlist"><ul type="disc"><li><p>字典可嵌套，可以在一个字典里包含另一个字典。如test={&quot;test&quot;:{&quot;mytest&quot;:10} }</p></li><li><p>可用键访问字典，如monthdays[&quot;Jan&quot;]，可访问值31。如果没有找到指定的键，则解释器会引起异常。</p></li><li><p>字典是可修改，如monthdays[&quot;Jan&quot;]=30，可把Jan的值由31改为30。如monthdays[&quot;test&quot;]=30可添加一个新键值对。</p></li><li><p>del monthdays[&quot;test&quot;]可删除字典条目。</p></li><li><p>字典不属序列对象，所以不能进行连接和相乘操作。字典是没有顺序的。</p></li><li><p>字典提供keys和values方法，用来返回字典中定义的所有键和值。</p></li><li><p>和列表一样，字典也提供了对象方法来对字典进行操作。</p><div class="table"><a name="id2876174"></a><p class="title"><b>Table 3.4. 字典方法</b></p><table summary="字典方法" border="1"><colgroup><col><col></colgroup><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>has_key(x)</td><td>如果字典中有键x，则返回真。</td></tr><tr><td>keys()</td><td>返回字典中键的列表</td></tr><tr><td>values()</td><td>返回字典中值的列表。</td></tr><tr><td>items()</td><td>返回tuples的列表。每个tuple由字典的键和相应值组成。</td></tr><tr><td>clear()</td><td>删除字典的所有条目。</td></tr><tr><td>copy()</td><td>返回字典高层结构的一个拷贝，但不复制嵌入结构，而只复制对那些结构的引用。</td></tr><tr><td>update(x)</td><td>用字典x中的键值对更新字典内容。</td></tr><tr><td>get(x[,y])</td><td>返回键x，若未找到该键返回none，若提供y，则未找到x时返回y。</td></tr></tbody></table></div></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2876321"></a>3.7. File文件</h2></div></div><div></div></div><p>可用内置的open()函数对文件进行操作。如：</p><pre class="screen">
input = open(&quot;test.txt&quot;)
for line in input.readlines():
    print line
input.close()
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2876343"></a>3.8. 理解引用</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Python把一块数据存储在对象中，变量是对象的唯一引用；它们是计算机内存中特殊地点的名字。所有对象都具有唯一的身份号、类型和值。对象的类型不会改变，对于可变类型而言，它的值是可变的。id(obj)函数可用于检索对象的身份，也就是内存中的对象的地址。</p></li><li><p>每个对象都包含引用计数器，它记录当前有多少个变量正在引用该对象。当给对象指定一个变量或使对象成为列表或其它包容器的成员时，引用计数就增加；当从包容器中撤消、重新分配或删除对象时，引用计数减少。当引用计数达到0值时(即没有任何变量引用这个对象)，python的回收机制会自动回收它使用的内存。注意，del可用来删除变量，但不能删除对象。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://www.kuqin.com/docs/images/note.png"></td><th align="left"></th></tr><tr><td colspan="2" align="left" valign="top">sys.gettrefcount(obj)函数可返回给定对象的引用计数。</td></tr></table></div></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2876409"></a>3.9. copy and deepcopy</h2></div></div><div></div></div><p>通过给列表分配一个变量能创建对列表的引用，如果要创建列表的副本就要理解浅副本和深副本的概念。</p><div class="itemizedlist"><ul type="disc"><li><p>列表或其他包容器对象的浅副本(Shallow)能够生成对象本身的副本，但也会创建对由列表包含的对象的引用。可用分片(object[:])和copy模块的copy(obj)函数创建。</p></li><li><p>列表或其他对象包容器对象的深副本能够生成对象本身的副本，并递归地生成所有子对象的副本。可用copy模块的deepcopy(obj)函数创建。</p></li></ul></div><p>比较两种副本，一般情况下表现一样，但当列表内包含另一个列表的情况下，父列表的浅副本将包含对子列表引用，而不是独立副本。其结果是，当更改内部列表时，从父列表的两个副本中都可见，如：</p><pre class="screen">
&gt;&gt;&gt; a=[1,2,3,[4,5]]
&gt;&gt;&gt; b=a[:]
&gt;&gt;&gt; b
[1, 2, 3, [4, 5]]
&gt;&gt;&gt; a[3].remove(4)
&gt;&gt;&gt; a
[1, 2, 3, [5]]
&gt;&gt;&gt; b
[1, 2, 3, [5]]
</pre><p>如果是深副本，就不会出现这种情况。如：</p><pre class="screen">
&gt;&gt;&gt; a=[1,2,3,[4,5]]
&gt;&gt;&gt; b=copy.deepcopy(a)
&gt;&gt;&gt; b
[1, 2, 3, [4, 5]]
&gt;&gt;&gt; a[3].remove(4)
&gt;&gt;&gt; a
[1, 2, 3, [5]]
&gt;&gt;&gt; b
[1, 2, 3, [4, 5]]
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2876486"></a>3.10. 标识数据类型</h2></div></div><div></div></div><p>可通过type(obj)函数标识数据类型，如：</p><pre class="screen">
&gt;&gt;&gt; type(a)
&lt;type 'list'&gt;
&gt;&gt;&gt; type(copy)
&lt;type 'module'&gt;
&gt;&gt;&gt; type(1)
&lt;type 'int'&gt;
</pre><p>types模块包含Python的内置数据类型的类型对象。如：</p><pre class="screen">
&gt;&gt;&gt; import types
&gt;&gt;&gt; types.ListType
&lt;type 'list'&gt;
&gt;&gt;&gt; types.IntType 
&lt;type 'int'&gt;
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2876523"></a>3.11. 数组对象</h2></div></div><div></div></div><p>数组对象与列表类似，但数组只包含某些类型的简单数据。所以当数据较简单，且要求性能好的情况下，使用数组是一个好的选择。</p><div class="table"><a name="id2876537"></a><p class="title"><b>Table 3.5. 数组类型代码</b></p><table summary="数组类型代码" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>代码</th><th>等价的C类型</th><th>以字节为单位的最小尺寸</th></tr></thead><tbody><tr><td>c</td><td>char</td><td>1</td></tr><tr><td>b(B)</td><td>byte(unsigned byte)</td><td>1</td></tr><tr><td>h(H)</td><td>short(unsigned short)</td><td>2</td></tr><tr><td>i(I)</td><td>int(unsigned int)</td><td>2</td></tr><tr><td>l(L)</td><td>long(unsigned long)</td><td>4</td></tr><tr><td>f</td><td>float</td><td>4</td></tr><tr><td>d</td><td>double</td><td>8</td></tr></tbody></table></div><p>数组创建方法如下：</p><pre class="screen">
&gt;&gt;&gt; import array
&gt;&gt;&gt; z=array.array(&quot;b&quot;)
&gt;&gt;&gt; z.append(1)
&gt;&gt;&gt; z
array('b', [1])
</pre><p>数组的itemsize和typecode成员可分别检索数组项的大小和数组对象的类型代码，如：</p><pre class="screen">
&gt;&gt;&gt; z.itemsize
1
&gt;&gt;&gt; z.typecode
'b'
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2876724"></a>3.1. 数组类型与其它数据类型的转换</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>tolist()方法可把数组转换为列表，如：</p><pre class="screen">
&gt;&gt;&gt; z.tolist()
[1, 2, 3]
</pre><p>fromlist(list)方法可把列表项附加到数组的末尾，如：</p><pre class="screen">
&gt;&gt;&gt; z.fromlist([10,11])
&gt;&gt;&gt; z
array('b', [1, 2, 3, 10, 11])
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://www.kuqin.com/docs/images/note.png"></td><th align="left"></th></tr><tr><td colspan="2" align="left" valign="top">如添加的列表类型与数组类型不同，则fromlist(list)不会把任何项添加到数组对象中。</td></tr></table></div></li><li><p>tostring()方法，可以把数组转换为字节的序列，如：</p><pre class="screen">
&gt;&gt;&gt; z.tostring()
'\x01\x02\x03\n\x0b'
</pre><p>fromstring(list)方法刚好与tostring()相反，它获取一个字节串，并把它们转换为数组的值。如：</p><pre class="screen">
&gt;&gt;&gt; z.fromstring(&quot;\x0b&quot;)
&gt;&gt;&gt; z
array('b', [1, 2, 3, 10, 11, 11])
</pre></li><li><p>tofile(file)方法可把数组转换为字节的序列，并把它们写入文件，如：</p><pre class="screen">
&gt;&gt;&gt; f=open(&quot;aa&quot;,&quot;wb&quot;)
&gt;&gt;&gt; z.tofile(f)
&gt;&gt;&gt; f.close()
</pre><p>fromfile(file,count)方法用于从文件对象中读取特定数目的项，并把它们附加到数组中，如：</p><pre class="screen">
&gt;&gt;&gt; z.fromfile(open(&quot;aa&quot;,&quot;rb&quot;),2)
&gt;&gt;&gt; z
array('b', [1, 2, 3, 10, 11, 11, 1, 2])
</pre><p>当取数项大于文件数据项时，formfile会产生EOFError异常。</p></li><li><p>数组对象支持列表中的很多相同函数和方法：len，append等。访问成员的方法也可列表一样，可用下标和分片。</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2876868"></a>Chapter 4. 控制语句</h2></div></div><div></div></div><p>流程控制是程序设计中一个重要的内容，Python支持三种不同的控制结构：if，for和while。</p><div class="itemizedlist"><ul type="disc"><li><p>if语句判断表达式是否为真，如果为真则执行指定语句。if语句的格式如下：</p><pre class="screen">
if   EXPRESSION1:
         STATEMENT1
elif EXPRESSION2:
         STATEMENT2
else:
         STATEMENT3
</pre><p>如果第一个表达式为真，则执行statement1，否则进行进一步的测试，如果第二个表达式为真则执行statement2，否则执行statement3。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://www.kuqin.com/docs/images/note.png"></td><th align="left"></th></tr><tr><td colspan="2" align="left" valign="top">注意语句的缩进量要保持一致。在python中没有switch和case语句，我们可通过多重elif来达到相同的效果。</td></tr></table></div><p>示例：</p><pre class="screen">
#!/usr/bin/env python

mytest = raw_input(&quot;please input a number:&quot;)
mytest = int(mytest)
if mytest == 10:
        print &quot;you input number is ten.&quot;
elif mytest == 20:
        print &quot;you input number is twenty.&quot;
else:
        print &quot;another number.&quot;

脚本的执行效果：
t03:~# python test.py
please input a number:10
you input number is ten.
t03:~# python test.py
please input a number:20
you input number is twenty.
t03:~# python test.py
please input a number:777
another number.
</pre></li><li><p>while进行循环控制，它对表达式进行测试，如果为真，则循环执行循环体。格式如下：</p><pre class="screen">
while EXPRESSION:
          STATEMENT
else:
          STATEMENT
</pre><p>如果测试为假，则会执行else块。如果循环被中断(break)，则else块不会执行。</p><p>示例：</p><pre class="screen">
&gt;&gt;&gt; a = 0
&gt;&gt;&gt; while a &gt; 5:
...     a = a + 1
...     print a
... else:
...     print &quot;a's value is five&quot;
... 
1
2
3
4
5
a's value is five
</pre></li><li><p>for循环可遍历对象，并可进行迭代操作。语名格式如下：</p><pre class="screen">
for TARGET in OBJECTS：
       STATEMENT
else:
       STATEMENT
</pre><p>和while一样，在循环正常退出时，会执行else块。</p><p>示例：</p><pre class="screen">
&gt;&gt;&gt; mylist = &quot;for statement&quot;
&gt;&gt;&gt; for word in mylist:
...     print word
... else:
...     print &quot;End list&quot;
... 
f
o
r
 
s
t
a
t
e
m
e
n
t
End list
</pre></li><li><p>在循环的过程中，我们可使用循环控制语句来控制循环的执行。有三个控制语句，分别是break、continue和pass。它们的作用分别是：</p><div class="itemizedlist"><ul type="circle"><li><p>break语句会立即退出当前循环，不会执行else块的内容。</p><p>示例：</p><pre class="screen">
&gt;&gt;&gt; mylist = [&quot;zope&quot;,&quot;python&quot;,&quot;perl&quot;,&quot;Linux&quot;]
&gt;&gt;&gt; for technic in mylist:
...     if technic == &quot;perl&quot;:
...             break
...     else:
...             print technic
... 
zope
python
</pre></li><li><p>continue语句会忽略后面的语句，强制进入下一次循环。</p><p>示例：</p><pre class="screen">
&gt;&gt;&gt; mylist = [&quot;zope&quot;,&quot;python&quot;,&quot;perl&quot;,&quot;Linux&quot;]
&gt;&gt;&gt; for technic in mylist:
...     if technic == &quot;perl&quot;:
...             continue
...     else:
...             print technic
... 
zope
python
Linux
</pre></li><li><p>pass不做任何事情。</p><p>示例：</p><pre class="screen">
&gt;&gt;&gt; for technic in mylist:
...     if technic == &quot;perl&quot;:
...             pass
...     else:
...             print technic
... 
zope
python
Linux
</pre></li></ul></div></li></ul></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2877126"></a>Chapter 5. 函数</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="pythonbasic.html#id2877464">5.1. 常用函数</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2877751">5.2. 内置类型转换函数</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2878060">5.3. 序列处理函数</a></span></dt></dl></div><p>函数是一个能完成特定功能的代码块，可在程序中重复使用，减少程序的代码量和提高程序的执行效率。在python中函数定义语法如下：</p><pre class="screen">
def function_name(arg1,arg2[,...]):
    statement
[return value]  
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://www.kuqin.com/docs/images/note.png"></td><th align="left"></th></tr><tr><td colspan="2" align="left" valign="top">返回值不是必须的，如果没有return语句，则Python默认返回值None。</td></tr></table></div><p>函数名的命名规则：</p><div class="itemizedlist"><ul type="disc"><li><p>函数名必须以下划线或字母开头，可以包含任意字母、数字或下划线的组合。不能使用任何的标点符号；</p></li><li><p>函数名是区分大小写的。</p></li><li><p>函数名不能是保留字。</p></li></ul></div><p>Python使用名称空间的概念存储对象，这个名称空间就是对象作用的区域， 不同对象存在于不同的作用域。下面是不同对象的作用域规则：</p><div class="itemizedlist"><ul type="disc"><li><p>每个模块都有自已的全局作用域。</p></li><li><p>函数定义的对象属局部作用域，只在函数内有效，不会影响全局作用域中的对象。</p></li><li><p>赋值对象属局部作用域，除非使用global关键字进行声明。</p></li></ul></div><p>LGB规则是Python查找名字的规则，下面是LGB规则：</p><div class="itemizedlist"><ul type="disc"><li><p>大多数名字引用在三个作用域中查找：先局部(Local)，次之全局(Global)，再次之内置(Build-in)。</p><pre class="screen">
&gt;&gt;&gt; a=2
&gt;&gt;&gt; b=2
&gt;&gt;&gt; def test(b):
...     test=a*b
...     return test
&gt;&gt;&gt;print test(10)
20
</pre><p>b在局部作用域中找到,a在全局作用域中找到。</p></li><li><p>如想在局部作用域中改变全局作用域的对象，必须使用global关键字。</p><pre class="screen">
#没用global时的情况
&gt;&gt;&gt; name=&quot;Jims&quot;
&gt;&gt;&gt; def set():
...     name=&quot;ringkee&quot;
...
&gt;&gt;&gt; set()
&gt;&gt;&gt; print name
Jims

#使用global后的情况
&gt;&gt;&gt; name=&quot;Jims&quot;
&gt;&gt;&gt; def set1():
...     global name
...     name=&quot;ringkee&quot;
...
&gt;&gt;&gt; set1()
&gt;&gt;&gt; print name
ringkee
</pre></li><li><p>'global'声明把赋值的名字映射到一个包含它的模块的作用域中。</p></li></ul></div><p>函数的参数是函数与外部沟通的桥梁，它可接收外部传递过来的值。参数传递的规则如下：</p><div class="itemizedlist"><ul type="disc"><li><p>在一个函数中对参数名赋值不影响调用者。</p><pre class="screen">
&gt;&gt;&gt; a=1
&gt;&gt;&gt; def test(a):
...     a=a+1
...     print a
...
&gt;&gt;&gt; test(a)
2
&gt;&gt;&gt; a
1             # a值不变
</pre></li><li><p>在一个函数中改变一个可变的对象参数会影响调用者。</p><pre class="screen">
&gt;&gt;&gt; a=1
&gt;&gt;&gt; b=[1,2]
&gt;&gt;&gt; def test(a,b):
...     a=5
...     b[0]=4
...     print a,b
...
&gt;&gt;&gt; test(a,b)
5 [4, 2]
&gt;&gt;&gt; a
1
&gt;&gt;&gt; b
[4, 2]    # b值已被更改
</pre></li></ul></div><p>参数是对象指针，无需定义传递的对象类型。如：</p><pre class="screen">
&gt;&gt;&gt; def test(a,b):
...     return a+b
...
&gt;&gt;&gt; test(1,2)   #数值型
3
&gt;&gt;&gt; test(&quot;a&quot;,&quot;b&quot;)   #字符型
'ab'
&gt;&gt;&gt; test([12],[11])   #列表
[12, 11]
</pre><p>函数中的参数接收传递的值，参数可分默认参数，如：</p><pre class="screen">
def function(ARG=VALUE)
</pre><p>元组（Tuples）参数：</p><pre class="screen">
def function(*ARG)
</pre><p>字典（dictionary）参数：</p><pre class="screen">
def function(**ARG)
</pre><p>一些函数规则：</p><div class="itemizedlist"><ul type="disc"><li><p>默认值必须在非默认参数之后；</p></li><li><p>在单个函数定义中，只能使用一个tuple参数（*ARG）和一个字典参数（**ARG）。</p></li><li><p>tuple参数必须在连接参数和默认参数之后。</p></li><li><p>字典参数必须在最后定义。</p></li></ul></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2877464"></a>5.1. 常用函数</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>abs(x)</p><p>abs()返回一个数字的绝对值。如果给出复数，返回值就是该复数的模。</p><pre class="screen">
&gt;&gt;&gt;print abs(-100)
100
&gt;&gt;&gt;print abs(1+2j)
2.2360679775
</pre></li><li><p>callable(object)</p><p>callable()函数用于测试对象是否可调用，如果可以则返回1(真)；否则返回0(假)。可调用对象包括函数、方法、代码对象、类和已经定义了“调用”方法的类实例。</p><pre class="screen">
&gt;&gt;&gt; a=&quot;123&quot;
&gt;&gt;&gt; print callable(a)
0
&gt;&gt;&gt; print callable(chr)
1
</pre></li><li><p>cmp(x,y)</p><p>cmp()函数比较x和y两个对象，并根据比较结果返回一个整数，如果x&lt;y，则返回-1；如果x&gt;y，则返回1,如果x==y则返回0。</p><pre class="screen">
&gt;&gt;&gt;a=1
&gt;&gt;&gt;b=2
&gt;&gt;&gt;c=2
&gt;&gt;&gt; print cmp(a,b)
-1
&gt;&gt;&gt; print cmp(b,a)
1
&gt;&gt;&gt; print cmp(b,c)
0
</pre></li><li><p>divmod(x,y)</p><p>divmod(x,y)函数完成除法运算，返回商和余数。</p><pre class="screen">
&gt;&gt;&gt; divmod(10,3)
(3, 1)
&gt;&gt;&gt; divmod(9,3)
(3, 0)
</pre></li><li><p>isinstance(object,class-or-type-or-tuple) -&gt; bool</p><p>测试对象类型</p><pre class="screen">
&gt;&gt;&gt; a='isinstance test'
&gt;&gt;&gt; b=1234
&gt;&gt;&gt; isinstance(a,str)
True
&gt;&gt;&gt; isinstance(a,int)
False
&gt;&gt;&gt; isinstance(b,str)
False
&gt;&gt;&gt; isinstance(b,int)
True
</pre></li><li><p>len(object) -&gt; integer</p><p>len()函数返回字符串和序列的长度。</p><pre class="screen">
&gt;&gt;&gt; len(&quot;aa&quot;)
2
&gt;&gt;&gt; len([1,2])
2
</pre></li><li><p>pow(x,y[,z])</p><p>pow()函数返回以x为底，y为指数的幂。如果给出z值，该函数就计算x的y次幂值被z取模的值。</p><pre class="screen">
&gt;&gt;&gt; print pow(2,4)
16
&gt;&gt;&gt; print pow(2,4,2)
0
&gt;&gt;&gt; print pow(2.4,3)
13.824
</pre></li><li><p>range([lower,]stop[,step])</p><p>range()函数可按参数生成连续的有序整数列表。</p><pre class="screen">
&gt;&gt;&gt; range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; range(1,10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; range(1,10,2)
[1, 3, 5, 7, 9]
</pre></li><li><p>round(x[,n])</p><p>round()函数返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</p><pre class="screen">
&gt;&gt;&gt; round(3.333)
3.0
&gt;&gt;&gt; round(3)
3.0
&gt;&gt;&gt; round(5.9)
6.0
</pre></li><li><p>type(obj)</p><p>type()函数可返回对象的数据类型。</p><pre class="screen">
&gt;&gt;&gt; type(a)
&lt;type 'list'&gt;
&gt;&gt;&gt; type(copy)
&lt;type 'module'&gt;
&gt;&gt;&gt; type(1)
&lt;type 'int'&gt;
</pre></li><li><p>xrange([lower,]stop[,step])</p><p>xrange()函数与range()类似，但xrnage()并不创建列表，而是返回一个xrange对象，它的行为与列表相似，但是只在需要时才计算列表值，当列表很大时，这个特性能为我们节省内存。</p><pre class="screen">
&gt;&gt;&gt; a=xrange(10)
&gt;&gt;&gt; print a[0]
0
&gt;&gt;&gt; print a[1]
1
&gt;&gt;&gt; print a[2]
2
</pre></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2877751"></a>5.2. 内置类型转换函数</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>chr(i)</p><p>chr()函数返回ASCII码对应的字符串。</p><pre class="screen">
&gt;&gt;&gt; print chr(65)
A
&gt;&gt;&gt; print chr(66)
B
&gt;&gt;&gt; print chr(65)+chr(66)
AB
</pre></li><li><p>complex(real[,imaginary])</p><p>complex()函数可把字符串或数字转换为复数。</p><pre class="screen">
&gt;&gt;&gt; complex(&quot;2+1j&quot;)
(2+1j)
&gt;&gt;&gt; complex(&quot;2&quot;)
(2+0j)
&gt;&gt;&gt; complex(2,1)
(2+1j)
&gt;&gt;&gt; complex(2L,1)
(2+1j)
</pre></li><li><p>float(x)</p><p>float()函数把一个数字或字符串转换成浮点数。</p><pre class="screen">
&gt;&gt;&gt; float(&quot;12&quot;)
12.0
&gt;&gt;&gt; float(12L)
12.0
&gt;&gt;&gt; float(12.2)
12.199999999999999
</pre></li><li><p>hex(x)</p><p>hex()函数可把整数转换成十六进制数。</p><pre class="screen">
&gt;&gt;&gt; hex(16)
'0x10'
&gt;&gt;&gt; hex(123)
'0x7b'
</pre></li><li><p>long(x[,base])</p><p>long()函数把数字和字符串转换成长整数，base为可选的基数。</p><pre class="screen">
&gt;&gt;&gt; long(&quot;123&quot;)
123L
&gt;&gt;&gt; long(11)
11L
</pre></li><li><p>list(x)</p><p>list()函数可将序列对象转换成列表。如：</p><pre class="screen">
&gt;&gt;&gt; list(&quot;hello world&quot;)
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
&gt;&gt;&gt; list((1,2,3,4))
[1, 2, 3, 4]
</pre></li><li><p>int(x[,base])</p><p>int()函数把数字和字符串转换成一个整数，base为可选的基数。</p><pre class="screen">
&gt;&gt;&gt; int(3.3)
3
&gt;&gt;&gt; int(3L)
3
&gt;&gt;&gt; int(&quot;13&quot;)
13
&gt;&gt;&gt; int(&quot;14&quot;,15)
19
</pre></li><li><p>min(x[,y,z...])</p><p>min()函数返回给定参数的最小值，参数可以为序列。</p><pre class="screen">
&gt;&gt;&gt; min(1,2,3,4)
1
&gt;&gt;&gt; min((1,2,3),(2,3,4))
(1, 2, 3)
</pre></li><li><p>max(x[,y,z...])</p><p>max()函数返回给定参数的最大值，参数可以为序列。</p><pre class="screen">
&gt;&gt;&gt; max(1,2,3,4)
4
&gt;&gt;&gt; max((1,2,3),(2,3,4))
(2, 3, 4)
</pre></li><li><p>oct(x)</p><p>oct()函数可把给出的整数转换成八进制数。</p><pre class="screen">
&gt;&gt;&gt; oct(8)
'010'
&gt;&gt;&gt; oct(123)
'0173'
</pre></li><li><p>ord(x)</p><p>ord()函数返回一个字符串参数的ASCII码或Unicode值。</p><pre class="screen">
&gt;&gt;&gt; ord(&quot;a&quot;)
97
&gt;&gt;&gt; ord(u&quot;a&quot;)
97
</pre></li><li><p>str(obj)</p><p>str()函数把对象转换成可打印字符串。</p><pre class="screen">
&gt;&gt;&gt; str(&quot;4&quot;)
'4'
&gt;&gt;&gt; str(4)
'4'
&gt;&gt;&gt; str(3+2j)
'(3+2j)'
</pre></li><li><p>tuple(x)</p><p>tuple()函数把序列对象转换成tuple。</p><pre class="screen">
&gt;&gt;&gt; tuple(&quot;hello world&quot;)
('h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd')
&gt;&gt;&gt; tuple([1,2,3,4])
(1, 2, 3, 4)
</pre></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2878060"></a>5.3. 序列处理函数</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>常用函数中的len()、max()和min()同样可用于序列。</p></li><li><p>filter(function,list)</p><p>调用filter()时，它会把一个函数应用于序列中的每个项，并返回该函数返回真值时的所有项，从而过滤掉返回假值的所有项。</p><pre class="screen">
&gt;&gt;&gt; def nobad(s):
...     return s.find(&quot;bad&quot;) == -1
... 
&gt;&gt;&gt; s = [&quot;bad&quot;,&quot;good&quot;,&quot;bade&quot;,&quot;we&quot;]
&gt;&gt;&gt; filter(nobad,s)
['good', 'we']
</pre><p>这个例子通过把nobad()函数应用于s序列中所有项，过滤掉所有包含“bad”的项。</p></li><li><p>map(function,list[,list])</p><p>map()函数把一个函数应用于序列中所有项，并返回一个列表。</p><pre class="screen">
&gt;&gt;&gt; import string
&gt;&gt;&gt; s=[&quot;python&quot;,&quot;zope&quot;,&quot;linux&quot;]
&gt;&gt;&gt; map(string.capitalize,s)
['Python', 'Zope', 'Linux']
</pre><p>map()还可同时应用于多个列表。如：</p><pre class="screen">
&gt;&gt;&gt; import operator
&gt;&gt;&gt; s=[1,2,3]; t=[3,2,1]
&gt;&gt;&gt; map(operator.mul,s,t)   # s[i]*t[j]
[3, 4, 3]
</pre><p>如果传递一个None值，而不是一个函数，则map()会把每个序列中的相应元素合并起来，并返回该元组。如：</p><pre class="screen">
&gt;&gt;&gt; a=[1,2];b=[3,4];c=[5,6]
&gt;&gt;&gt; map(None,a,b,c)
[(1, 3, 5), (2, 4, 6)]
</pre></li><li><p>reduce(function,seq[,init])</p><p>reduce()函数获得序列中前两个项，并把它传递给提供的函数，获得结果后再取序列中的下一项，连同结果再传递给函数，以此类推，直到处理完所有项为止。</p><pre class="screen">
&gt;&gt;&gt; import operator
&gt;&gt;&gt; reduce(operator.mul,[2,3,4,5])  # ((2*3)*4)*5
120
&gt;&gt;&gt; reduce(operator.mul,[2,3,4,5],1) # (((1*2)*3)*4)*5
120
&gt;&gt;&gt; reduce(operator.mul,[2,3,4,5],2)  # (((2*2)*3)*4)*5
240
</pre></li><li><p>zip(seq[,seq,...])</p><p>zip()函数可把两个或多个序列中的相应项合并在一起，并以元组的格式返回它们，在处理完最短序列中的所有项后就停止。</p><pre class="screen">
&gt;&gt;&gt; zip([1,2,3],[4,5],[7,8,9])
[(1, 4, 7), (2, 5, 8)]
</pre><p>如果参数是一个序列，则zip()会以一元组的格式返回每个项，如：</p><pre class="screen">
&gt;&gt;&gt; zip((1,2,3,4,5))
[(1,), (2,), (3,), (4,), (5,)]
&gt;&gt;&gt; zip([1,2,3,4,5])
[(1,), (2,), (3,), (4,), (5,)]
</pre></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2878241"></a>Chapter 6. 模块</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="pythonbasic.html#id2878430">6.1. String模块</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2878537">6.2. time模块</a></span></dt></dl></div><p>模块可把一个复杂的程序按功能分开，分别存放到不同文件中，使程序更容易维护和管理。在Python中的模块是一个以.py结尾的Python代码文件。可通过import命令输入，如：</p><pre class="screen">
import sys
</pre><p>import会完成以下三个操作：</p><div class="itemizedlist"><ul type="disc"><li><p>创建新的名称空间（namespace），该名称空间中拥有输入模块中定义的所有对象；</p></li><li><p>执行模块中的代码；</p></li><li><p>创建该名称空间的变量名。</p></li></ul></div><p>import语句可同时输入多个模块，如：</p><pre class="screen">
import os,sys,system
</pre><p>也可写成：</p><pre class="screen">
import os
import sys
import system
</pre><p>有些模块的名称很长，我们可在输入时给它起个简单的别名，这样在使用模块中的对象就方便很多，如：</p><pre class="screen">
import ftplib as ftp
</pre><p>有时我们可能只想使用模块中某个对象，又不想把整个模块输入，则可以用from...import语句输入特定对象。如：</p><pre class="screen">
from ftplib import FTP
</pre><p>这样，我们就可直接使用FTP()，而不用带前缀。</p><p>如果装载模块出错，会引发ImportError异常。我们可捕获该异常进行相应处理。</p><p>Python脚本和模块都是一个以.py结束的文件，那程序是如何判断一个.py文件是作为脚本还是模块呢？关键是一个名为__name__的变量，如果它的值是__main__，则不能作为模块，只能作为脚本直接运行。所以在很多脚本的最后都有一段类似下面的语句，限制只能以脚本方式运行，不作为模块：</p><pre class="screen">
if __name__ == '__main__':
    main()
</pre><p>几个功能相近的模块我们可组成一个Python包，存放到一个目录结构中，通过输入包的路径来调用对象。要定义包，就要建一个与包名同名的目录，接着在该目录下创建__init__.py文件。该文件是包的初始化文件，可以为空，也可定义一个代码。例如一个WebDesign包的目录如下：</p><pre class="screen">
/WebDesign
        __init_.py
        design.py
        draw.py
        ...
</pre><p>我们可通过以下语句输入design模块：</p><pre class="screen">
import WebDesign.design
</pre><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2878430"></a>6.1. String模块</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>replace(string,old,new[,maxsplit])</p><p>字符串的替换函数，把字符串中的old替换成new。默认是把string中所有的old值替换成new值，如果给出maxsplit值，还可控制替换的个数，如果maxsplit为1，则只替换第一个old值。</p><pre class="screen">
&gt;&gt;&gt;a=&quot;11223344&quot;
&gt;&gt;&gt;print string.replace(a,&quot;1&quot;,&quot;one&quot;)
oneone2223344
&gt;&gt;&gt;print string.replace(a,&quot;1&quot;,&quot;one&quot;,1)
one12223344
</pre></li><li><p>capitalize(string)</p><p>该函数可把字符串的首个字符替换成大字。</p><pre class="screen">
&gt;&gt;&gt; import string
&gt;&gt;&gt; print string.capitalize(&quot;python&quot;)
Python
</pre></li><li><p>split(string,sep=None,maxsplit=-1)</p><p>从string字符串中返回一个列表，以sep的值为分界符。</p><pre class="screen">
&gt;&gt;&gt; import string
&gt;&gt;&gt; ip=&quot;192.168.3.3&quot;
&gt;&gt;&gt; ip_list=string.split(ip,'.')
&gt;&gt;&gt; print ip_list
['192', '168', '3', '3']
</pre></li><li><p>join(string[,sep])</p><p>返回用sep连接的字串，默认的sep是空格。</p><pre class="screen">
&gt;&gt;&gt; import string
&gt;&gt;&gt; a = ['a','b','c']
&gt;&gt;&gt; b = string.join(a,'-')
&gt;&gt;&gt; b
'a-b-c'
&gt;&gt;&gt; a
['a', 'b', 'c']
</pre></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2878537"></a>6.2. time模块</h2></div></div><div></div></div><p>内置模块time包含很多与时间相关函数。我们可通过它获得当前的时间和格式化时间输出。</p><div class="itemizedlist"><ul type="disc"><li><p>time()，以浮点形式返回自Linux新世纪以来经过的秒数。在linux中，00:00:00 UTC, January 1, 1970是新纪元的开始。</p><pre class="screen">
&gt;&gt;&gt; time.time()
1150269086.6630149
&gt;&gt;&gt; time.ctime(1150269086.6630149)
&gt;&gt;&gt; 'Wed Jun 14 15:11:26 2006'
</pre></li><li><p>ctime([sec])，把秒数转换成日期格式，如果不带参数，则显示当前的时间。</p><pre class="screen">
&gt;&gt;&gt; import time
&gt;&gt;&gt; time.ctime()
&gt;&gt;&gt; 'Wed Jun 14 15:02:50 2006'
&gt;&gt;&gt; time.ctime(1138068452427683)
'Sat Dec 14 04:51:44 1901'                               
</pre></li><li><p>sleep(secs)，定时。</p><pre class="screen">
&gt;&gt;&gt; time.sleep(10) 
&gt;&gt;&gt;                #10秒后才会出现&gt;&gt;&gt;提示符 
</pre></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2878619"></a>Chapter 7. 类</h2></div></div><div></div></div><p>类是面向对象编程的一个重要概念。通过类的创建和继承，可重用代码，减少代码复杂度。Python是一种面向对象的脚本语言，用class语句可创建类，语法规则如下：</p><pre class="screen">
class classnmae([class_parent,...]):
      ...
      def method():
          ...
...
</pre><p>一个例子：</p><pre class="screen">
#!/usr/bin/python
#-*- encoding:utf-8 -*-

class test:                              #定义一个test类
        desc = &quot;这是一个测试类。&quot;        #在类中定义一个属性desc

        def __init__(self,name1):        #对象构造函数，初始化类
                self.name1 = name1

        def show(self,name2):            #在类中定义一个方法show()
                print &quot;hello world&quot;
                print 'name1:',self.name1
                print 'name2:',name2

instance = test('这是传递给name1的值')   #生成test类的实例对象instance

print instance.desc                      #调用类中的desc属性

instance.show('这是传递给name2的值')     #调用类中的show()方法
</pre><p>把该脚本命名为test.py，并用chmod +x test.py使脚本有执行的权限 ，运行该脚本结果如下：</p><pre class="screen">
debian:~/python# ./test.py
这是一个测试类。
hello world
name1: 这是传递给name1的值
name2: 这是传递给name2的值
</pre><p>这里只是Python语言中类的一个简单介绍。详细介绍可参考网站上自由文档栏目中的Python资料。</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2878694"></a>Chapter 8. 异常处理</h2></div></div><div></div></div><p>Python的异常处理能力是很强大的，可向用户准确反馈出错信息。在Python中，异常也是对象，可对它进行操作。所有异常都是基类Exception的成员。异常处理的try语法有两种，一种是：</p><pre class="screen">
try:
   block
except [exception,[data...]]:
   block
else:
   block
</pre><p>该种异常处理语法的规则是：</p><div class="itemizedlist"><ul type="disc"><li><p>执行try下的语句，如果引发异常，则执行过程会跳到第一个except语句。</p></li><li><p>如果第一个except中定义的异常与引发的异常匹配，则执行该except中的语句。</p></li><li><p>如果引发的异常不匹配第一个except，则会搜索第二个except，允许编写的except数量没有限制。</p></li><li><p>如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。</p></li><li><p>如果没有发生异常，则执行else块代码。</p></li></ul></div><p>try语句的第二种语法是：</p><pre class="screen">
try:
   block
finally:
   block
</pre><p>该语句的执行规则是：</p><div class="itemizedlist"><ul type="disc"><li><p>执行try下的代码。</p></li><li><p>如果发生异常，在该异常传递到下一级try时，执行finally中的代码。</p></li><li><p>如果没有发生异常，则执行finally中的代码。</p></li></ul></div><p>第二种try语法在无论有没有发生异常都要执行代码的情况下是很有用的。例如我们在python中打开一个文件进行读写操作，我在操作过程中不管是否出现异常，最终我都是要把该文件关闭的。</p><p>除了系统引发的异常外，我们还可用raise语句手工引发一个异常：</p><pre class="screen">
raise [exception[,data]]
</pre></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2878856"></a>Chapter 9. 文件处理</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="pythonbasic.html#id2878871">9.1. 文件处理的函数和方法</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2879330">9.2. 示例</a></span></dt></dl></div><p>文件是我们储存信息的地方，我们经常要对文件进行读、写、删除等的操作，在Python中，我们可用Python提供的函数和方法方便地操作文件。</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2878871"></a>9.1. 文件处理的函数和方法</h2></div></div><div></div></div><p>使用Open()函数可打开文件，语法格式如下：</p><pre class="screen">
file_handler = open(filename,[,mode[,bufsize]]
</pre><p>filename是你要操作的文件名，如果不在当前路径，需指出具体路径。mode是打开文件的模式，表示你要如何操作文件，bufsize表示是否使用缓存。</p><div class="table"><a name="id2878904"></a><p class="title"><b>Table 9.1. mode</b></p><table summary="mode" border="1"><colgroup><col><col></colgroup><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>以读方式打开文件，可读取文件信息。</td></tr><tr><td>w</td><td>以写方式打开文件，可向文件写入信息。</td></tr><tr><td>a</td><td>以追加方式打开文件，文件指针自动移到文件尾。</td></tr><tr><td>r+</td><td>以读写方式打开文件，可对文件进行读和写操作。</td></tr><tr><td>w+</td><td>消除文件内容，然后以读写方式打开文件。</td></tr><tr><td>a+</td><td>以读写方式打开文件，并把文件指针移到文件尾。</td></tr><tr><td>b</td><td>以二进制模式打开文件，而不是以文本模式。该模式只对Windows或Dos有效，类Unix的文件是用二进制模式进行操作的。</td></tr></tbody></table></div><div class="table"><a name="id2879035"></a><p class="title"><b>Table 9.2. bufsize</b></p><table summary="bufsize" border="1"><colgroup><col><col></colgroup><thead><tr><th>bufsize取值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>禁用缓冲</td></tr><tr><td>1</td><td>行缓冲</td></tr><tr><td>&gt;1</td><td>指定缓冲区的大小</td></tr><tr><td>&lt;1</td><td>系统默认的缓冲区大小</td></tr></tbody></table></div><p>open()函数返回一个文件对象，我们可通过read()或write()函数对文件进行读写操作，下面是一些文件对象方法：</p><div class="table"><a name="id2879132"></a><p class="title"><b>Table 9.3. 文件对象方法</b></p><table summary="文件对象方法" border="1"><colgroup><col><col></colgroup><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>f.close()</td><td>关闭文件，记住用open()打开文件后一定要记得关闭它，否则会占用系统的可打开文件句柄数。</td></tr><tr><td>f.fileno()</td><td>获得文件描述符</td></tr><tr><td>f.flush()</td><td>刷新输出缓存</td></tr><tr><td>f.isatty()</td><td>如果文件是一个交互终端，则返回True，否则返回False。</td></tr><tr><td>f.read([count])</td><td>读出文件，如果有count，则读出count个字节。</td></tr><tr><td>f.readline()</td><td>读出一行信息。</td></tr><tr><td>f.readlines()</td><td>读出所有行，也就是读出整个文件的信息。</td></tr><tr><td>f.seek(offset[,where])</td><td>把文件指针移动到相对于where的offset位置。offset为0表示文件开始处，这是默认值 ；1表示当前位置；2表示文件结尾。</td></tr><tr><td>f.tell()</td><td>获得文件指针位置。</td></tr><tr><td>f.truncate([size])</td><td>截取文件，使文件的大小为size。</td></tr><tr><td>f.write(string)</td><td>把string字符串写入文件。</td></tr><tr><td>f.writelines(list)</td><td>把list中的字符串一行一行地写入文件。</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2879330"></a>9.2. 示例</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>文件的打开或创建</p><pre class="screen">
#!/usr/bin/env python
#-*- encoding:UTF-8 -*-

filehandler = open('test.txt','w')               #以写模式打开文件，如果文件不存在则创建
filehandler.write('this is a file open/create test.\nthe second line.')

filehandler.close()
</pre><pre class="screen">
#!/usr/bin/env python
#-*- encoding:UTF-8 -*-

filehandler = open('test.txt','a')      #以追加模式打开文件，如果文件不存在则创建

filehandler.write('\nappend the text in another line.\n')

filehandler.close()
</pre></li><li><p>读取文件</p><pre class="screen">
#!/usr/bin/env python
#-*- encoding:UTF-8 -*-

filehandler = open('test.txt','r')    #以读方式打开文件，rb为二进制方式(如图片或可执行文件等)
 
print 'read() function:'              #读取整个文件
print filehandler.read()
 
print 'readline() function:'          #返回文件头，读取一行
filehandler.seek(0)
print filehandler.readline()
 
print 'readlines() function:'         #返回文件头，返回所有行的列表
filehandler.seek(0)
print filehandler.readlines()
 
print 'list all lines'                #返回文件头，显示所有行
filehandler.seek(0)
textlist = filehandler.readlines()
for line in textlist:
      print line

print 'seek() function'               #移位到第32个字符，从33个字符开始显示余下内容
filehandler.seek(32)
print filehandler.read()

print 'tell() function'               #移位到文件头，从头开始显示2位字符
filehandler.seek(0)
print filehandler.readline()          #显示第一行内容
print filehandler.tell()              #显示当前位置
print filehandler.readline()          #显示第二行内容
print filehandler.read()              #显示余下所有内容

filehandler.close()                   #关闭文件句柄
</pre></li><li><p>文件系统操作</p><pre class="screen">
#!/usr/bin/env python
#-*- encoding:utf-8 -*-

import os,fnmatch,glob

for fileName in os.listdir ( '/root' ):                 #列出/root目录内容，不包括.和..
   print fileName 

os.mkdir('py')                  #在当前目录下创建一个py目录，且只能创建一层
os.rmdir( 'py')                 #在当前目录下删除py目录，且只能删除一层
os.makedirs('py/aa')            #可创建多层目录
os.removedirs('py/aa')          #可删除多层目录


print 'demonstration fnmatch module'                 
for fileName in os.listdir ( '/root/python/file' ):
        if fnmatch.fnmatch(fileName,'*.txt'):        #利用UNIX风格的通配，只显示后缀为txt的文件
                print fileName

print 'demonstration glob module'
for fileName in glob.glob ( '*.txt' ):               #利用UNIX风格的通配，只显示后缀为txt的文件
        print fileName 
</pre></li><li><p>获取文件状态</p><pre class="screen">
#!/usr/bin/env python
#-*- encoding:UTF-8 -*-

import os,time,stat

fileStats = os.stat ( 'test.txt' )                         #获取文件/目录的状态
fileInfo = {
'Size':fileStats [ stat.ST_SIZE ],                         #获取文件大小
'LastModified':time.ctime( fileStats [ stat.ST_MTIME ] ),  #获取文件最后修改时间
'LastAccessed':time.ctime( fileStats [ stat.ST_ATIME ] ),  #获取文件最后访问时间
'CreationTime':time.ctime( fileStats [ stat.ST_CTIME ] ),  #获取文件创建时间
'Mode':fileStats [ stat.ST_MODE ]                          #获取文件的模式
}
#print fileInfo

for field in fileInfo:                                     #显示对象内容
        print '%s:%s' % (field,fileInfo[field])

#for infoField,infoValue in fileInfo:
#       print '%s:%s' % (infoField,infoValue)
if stat.S_ISDIR ( fileStats [ stat.ST_MODE ] ):             #判断是否路径
        print 'Directory. '
else:
        print 'Non-directory.'

if stat.S_ISREG ( fileStats [ stat.ST_MODE ] ):             #判断是否一般文件
   print 'Regular file.'
elif stat.S_ISLNK ( fileStats [ stat.ST_MODe ] ):           #判断是否链接文件
   print 'Shortcut.'
elif stat.S_ISSOCK ( fileStats [ stat.ST_MODe ] ):          #判断是否套接字文件     
   print 'Socket.'
elif stat.S_ISFIFO ( fileStats [ stat.ST_MODe ] ):          #判断是否命名管道
   print 'Named pipe.'
elif stat.S_ISBLK ( fileStats [ stat.ST_MODe ] ):           #判断是否块设备
   print 'Block special device.'
elif stat.S_ISCHR ( fileStats [ stat.ST_MODe ] ):           #判断是否字符设置
   print 'Character special device.'
</pre><pre class="screen">
#!/usr/bin/env python
#-*- encoding:UTF-8 -*-

import os.path

fileStats = 'test.txt'

if os.path.isdir ( fileStats ):         #判断是否路径
        print 'Directory.'
elif os.path.isfile ( fileStats ):      #判断是否一般文件
        print 'File.'
elif os.path.islink ( fileStats ):      #判断是否链接文件
        print 'Shortcut.'
elif os.path.ismount ( fileStats ):     #判断是否挂接点
        print 'Mount point.'
</pre><p>stat模块描述了os.stat(filename)返回的文件属性列表中各值的意义。我们可方便地根据stat模块存取os.stat()中的值。</p></li><li><p>串行化文件</p><pre class="screen">
#!/usr/bin/env python
#-*- encoding:UTF-8 -*-

import pickle

filehandler = open('pickle.txt','w')

text = ['this is a pickle demonstrate','aa','bb']

pickle.dump(text,filehandler)           #把text的内容序列化后保存到pickle.txt文件中

filehandler.close()

filehandler2 = open('pickle.txt')

textlist = pickle.load(filehandler2)    #还原序列化字符串
print textlist

filehandler2.close()

#cpickle是用C写的pickle模块，比标准的pickle速度快很多，使用方法同pickle。
</pre></li><li><p>内存文件</p><pre class="screen">
#!/usr/bin/env python
#-*- coding: utf-8 -*-

import StringIO

fileHandle = StringIO.StringIO ( &quot;Let freedom ring.&quot; )   #create file in memory

print fileHandle.read() # &quot;Let freedom ring.&quot;

fileHandle.close()

#cStringIO是用C写的StringIO模块，执行速度比StringIO快。
</pre></li></ul></div></div><p>shutil模块是一个高级的文件处理模块，可实现文件的拷贝、删除等操作。</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2879657"></a>Chapter 10. 正则表达式</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="pythonbasic.html#id2879700">10.1. 基本元素</a></span></dt><dt><span class="sect1"><a href="pythonbasic.html#id2880568">10.2. 操作</a></span></dt></dl></div><p>正则表达式是一个很有用的工具，可处理复杂的字符匹配和替换工作。在Python中内置了一个re模块以支持正则表达式。</p><p>正则表达式有两种基本的操作，分别是匹配和替换。</p><div class="itemizedlist"><ul type="disc"><li><p>匹配就是在一个文本字符串中搜索匹配一特殊表达式；</p></li><li><p>替换就是在一个字符串中查找并替换匹配一特殊表达式的字符串。</p></li></ul></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2879700"></a>10.1. 基本元素</h2></div></div><div></div></div><p>正则表达式定义了一系列的特殊字符元素以执行匹配动作。</p><div class="table"><a name="id2879712"></a><p class="title"><b>Table 10.1. 正则表达式基本字符</b></p><table summary="正则表达式基本字符" border="1"><colgroup><col><col></colgroup><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>匹配text字符串</td></tr><tr><td>.</td><td>匹配除换行符之外的任意一个单个字符</td></tr><tr><td>^</td><td>匹配一个字符串的开头</td></tr><tr><td>$</td><td>匹配一个字符串的末尾</td></tr></tbody></table></div><p>在正则表达式中，我们还可用匹配限定符来约束匹配的次数。</p><div class="table"><a name="id2879806"></a><p class="title"><b>Table 10.2. 匹配限定符</b></p><table summary="匹配限定符" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>最大匹配</th><th>最小匹配</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>* </td><td>重复匹配前表达式零次或多次</td></tr><tr><td>+</td><td>+ </td><td>重复匹配前表达式一次或多次</td></tr><tr><td> </td><td>  </td><td>重复匹配前表达式零次或一次</td></tr><tr><td>{m}</td><td>{m} </td><td>精确重复匹配前表达式m次</td></tr><tr><td>{m,}</td><td>{m,} </td><td>至少重复匹配前表达式m次</td></tr><tr><td>{m,n}</td><td>{m,n} </td><td>至少重复匹配前表达式m次，至多重复匹配前表达式n次</td></tr></tbody></table></div><p>据上所述，&quot;.*&quot;为最大匹配，能匹配源字符串所有能匹配的字符串。&quot;.* &quot;为最小匹配，只匹配第一次出现的字符串。如：d.*g能匹配任意以d开头，以g结尾的字符串，如&quot;debug&quot;和&quot;debugging&quot;，甚至&quot;dog is walking&quot;。而d.* g只能匹配&quot;debug&quot;，在&quot;dog is walking&quot;字符串中，则只匹配到&quot;dog &quot;。</p><p>在一些更复杂的匹配中，我们可用到组和运算符。</p><div class="table"><a name="id2879972"></a><p class="title"><b>Table 10.3. 组和运算符</b></p><table summary="组和运算符" border="1"><colgroup><col><col></colgroup><thead><tr><th>组</th><th>描述</th></tr></thead><tbody><tr><td>[...]</td><td>匹配集合内的字符，如[a-z],[1-9]或[,./;']</td></tr><tr><td>[^...]</td><td>匹配除集合外的所有字符，相当于取反操作</td></tr><tr><td>A|B</td><td>匹配表达式A或B，相当于OR操作</td></tr><tr><td>(...)</td><td>表达式分组，每对括号为一组，如([a-b]+)([A-Z]+)([1-9]+)</td></tr><tr><td>\number</td><td>匹配在number表达式组内的文本</td></tr></tbody></table></div><p>有一组特殊的字符序列，用来匹配具体的字符类型或字符环境。如\b匹配字符边界，food\b匹配&quot;food&quot;、&quot;zoofood&quot;，而和&quot;foodies&quot;不匹配。</p><div class="table"><a name="id2880082"></a><p class="title"><b>Table 10.4. 特殊字符序列</b></p><table summary="特殊字符序列" border="1"><colgroup><col><col></colgroup><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\A</td><td>只匹配字符串的开始</td></tr><tr><td>\b</td><td>匹配一个单词边界</td></tr><tr><td>\B</td><td>匹配一个单词的非边界</td></tr><tr><td>\d</td><td>匹配任意十进制数字字符，等价于r'[0-9]'</td></tr><tr><td>\D</td><td>匹配任意非十进制数字字符，等价于r'[^0-9]'</td></tr><tr><td>\s</td><td>匹配任意空格字符（空格符、tab制表符、换行符、回车、换页符、垂直线符号）</td></tr><tr><td>\S</td><td>匹配任意非空格字符</td></tr><tr><td>\w</td><td>匹配任意字母数字字符</td></tr><tr><td>\W</td><td>匹配任意非字母数字字符</td></tr><tr><td>\Z</td><td>仅匹配字符串的尾部</td></tr><tr><td>\\</td><td>匹配反斜线字符</td></tr></tbody></table></div><p>有一套声明(assertion)对具体事件进行声明。</p><div class="table"><a name="id2880267"></a><p class="title"><b>Table 10.5. 正则表达式声明</b></p><table summary="正则表达式声明" border="1"><colgroup><col><col></colgroup><thead><tr><th>声明</th><th>描述</th></tr></thead><tbody><tr><td>( iLmsux)</td><td>匹配空字符串，iLmsux字符对应下表的正则表达式修饰符。</td></tr><tr><td>( :...)</td><td>匹配圆括号内定义的表达式，但不填充字符组表。</td></tr><tr><td>( P&lt;name&gt;)</td><td>匹配圆括号内定义的表达式，但匹配的表达式还可用作name标识的符号组。</td></tr><tr><td>( P=name)</td><td>匹配所有与前面命名的字符组相匹配的文本。</td></tr><tr><td>( #...)</td><td>引入注释，忽略圆括号内的内容。</td></tr><tr><td>( =...)</td><td>如果所提供的文本与下一个正则表达式元素匹配，这之间没有多余的文本就匹配。这允许在一个表达式中进行超前操作，而不影响正则表达式其余部分的分析。如&quot;Martin&quot;其后紧跟&quot;Brown&quot;，则&quot;Martin( =Brown)&quot;就只与&quot;Martin&quot;匹配。</td></tr><tr><td>( !...)</td><td>仅当指定表达式与下一个正则表达式元素不匹配时匹配，是( =...)的反操作。</td></tr><tr><td>( &lt;=...)</td><td>如果字符串当前位置的前缀字符串是给定文本，就匹配，整个表达式就在当前位置终止。如( &lt;=abc)def表达式与&quot;abcdef&quot;匹配。这种匹配是对前缀字符数量的精确匹配。</td></tr><tr><td>( &lt;!...)</td><td>如果字符串当前位置的前缀字符串不是给定的正文，就匹配，是( &lt;=...)的反操作。</td></tr></tbody></table></div><p>正则表达式还支持一些处理标志，它会影响正则式的执行方法。</p><div class="table"><a name="id2880446"></a><p class="title"><b>Table 10.6. 处理标志</b></p><table summary="处理标志" border="1"><colgroup><col><col></colgroup><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>I或IGNORECASE</td><td>忽略表达式的大小写来匹配文本。</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2880568"></a>10.2. 操作</h2></div></div><div></div></div><p>通过re模块，我们就可在python中利用正则式对字符串进行搜索、抽取和替换操作。如：re.search()函数能执行一个基本的搜索操作，它能返回一个MatchObject对象。re.findall()函数能返回匹配列表。</p><pre class="screen">
&gt;&gt;&gt; import re
&gt;&gt;&gt; a=&quot;this is my re module test&quot;
&gt;&gt;&gt; obj = re.search(r'.*is',a)
&gt;&gt;&gt; print obj
&lt;_sre.SRE_Match object at 0xb7d7a218&gt;
&gt;&gt;&gt; obj.group()
'this is'
&gt;&gt;&gt; re.findall(r'.*is',a)
['this is']
</pre><p>MatchObject对象方法</p><div class="table"><a name="id2880594"></a><p class="title"><b>Table 10.7. MatchObject对象方法</b></p><table summary="MatchObject对象方法" border="1"><colgroup><col><col></colgroup><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>expand(template)</td><td>展开模板中用反斜线定义的内容。</td></tr><tr><td>m.group([group,...])</td><td>返回匹配的文本，是个元组。此文本是与给定group或由其索引数字定义的组匹配的文本，如果没有组定组名，则返回所有匹配项。</td></tr><tr><td>m.groups([default])</td><td>返回一个元组，该元组包含模式中与所有组匹配的文本。如果给出default参数，default参数值就是与给定表达式不匹配的组的返回值。default参数的默认取值为None。</td></tr><tr><td>m.groupdict([default])</td><td>返回一个字典，该字典包含匹配的所有子组。如果给出default参数，其值就是那些不匹配组的返回值。default参数的默认取值为None。</td></tr><tr><td>m.start([group])</td><td>返回指定group的开始位置，或返回全部匹配的开始位置。</td></tr><tr><td>m.end([group])</td><td>返回指定group的结束位置，或返回全部匹配的结束位置。</td></tr><tr><td>m.span([group])</td><td>返回两元素组，此元组等价于关于一给定组或一个完整匹配表达式的(m.start(group),m.end(group)))列表</td></tr><tr><td>m.pos</td><td>传递给match()或search()函数的pos值。</td></tr><tr><td>m.endpos</td><td>传递给match()或search()函数的endpos值。</td></tr><tr><td>m.lastindex</td><td> </td></tr><tr><td>m.lastgroup</td><td> </td></tr><tr><td>m.re</td><td>创建这个MatchObject对象的正则式对象</td></tr><tr><td>m.string</td><td>提供给match()或search()函数的字符串。</td></tr></tbody></table></div><p>使用sub()或subn()函数可在字符串上执行替换操作。sub()函数的基本格式如下：</p><pre class="screen">
sub(pattern,replace,string[,count])
</pre><p>示例</p><pre class="screen">
&gt;&gt;&gt; str = 'The dog on my bed'
&gt;&gt;&gt; rep = re.sub('dog','cat',str)
&gt;&gt;&gt; print rep
The cat on my bed
</pre><p>replace参数可接受函数。要获得替换的次数，可使用subn()函数。subn()函数返回一个元组，此元组包含替换了的文本和替换的次数。</p><p>如果需用同一个正则式进行多次匹配操作，我们可把正则式编译成内部语言，提高处理速度。编译正则式用compile()函数来实现。compile()函数的基本格式如下：</p><pre class="screen">
compile(str[,flags])
</pre><p>str表示需编译的正则式串，flags是修饰标志符。正则式被编译后生成一个对象，该对象有多种方法和属性。</p><div class="table"><a name="id2880883"></a><p class="title"><b>Table 10.8. 正则式对象方法/属性</b></p><table summary="正则式对象方法/属性" border="1"><colgroup><col><col></colgroup><thead><tr><th>方法/属性</th><th>描述</th></tr></thead><tbody><tr><td>r.search(string[,pos[,endpos]])</td><td>同search()函数，但此函数允许指定搜索的起点和终点</td></tr><tr><td>r.match(string[,pos[,endpos]])</td><td>同match()函数，但此函数允许指定搜索的起点和终点</td></tr><tr><td>r.split(string[,max])</td><td>同split()函数</td></tr><tr><td>r.findall(string)</td><td>同findall()函数</td></tr><tr><td>r.sub(replace,string[,count])</td><td>同sub()函数</td></tr><tr><td>r.subn(replace,string[,count])</td><td>同subn()函数</td></tr><tr><td>r.flags</td><td>创建对象时定义的标志</td></tr><tr><td>r.groupindex</td><td>将r'( Pid)'定义的符号组名字映射为组序号的字典</td></tr><tr><td>r.pattern</td><td>在创建对象时使用的模式</td></tr></tbody></table></div><p>转义字符串用re.escape()函数。</p></div></div><p>通过getattr获取对象引用</p><pre class="screen">
&gt;&gt;&gt; li=['a','b']
&gt;&gt;&gt; getattr(li,'append')
&gt;&gt;&gt; getattr(li,'append')('c')          #相当于li.append('c')
&gt;&gt;&gt; li
['a', 'b', 'c']
&gt;&gt;&gt; handler=getattr(li,'append',None)
&gt;&gt;&gt; handler
&lt;built-in method append of list object at 0xb7d4a52c&gt;
&gt;&gt;&gt; handler('cc')                      #相当于li.append('cc')
&gt;&gt;&gt; li
['a','b','c','cc']
&gt;&gt;&gt;result = handler('bb')
&gt;&gt;&gt;li
['a','b','c','cc','bb']
&gt;&gt;&gt;print result
None
</pre><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2881059"></a>Chapter 11. 调试</h2></div></div><div></div></div><p>Python自带了一个调试器叫pdb，和Gnu的gbd类似。下面用一个简单的程序来演示pdb的功能。程序代码如下：</p><pre class="screen">
#!/usr/bin/python

import pdb
a = &quot;aaa&quot;
pdb.set_trace()
b = &quot;bbb&quot;
c = &quot;ccc&quot;
final = a + b + c
print final
</pre><p>该程序已导入pdb模块，并在代码中添加的pdb.set_trace()跟踪点。现在让我们来运行该程序。</p><pre class="screen">
localhost:~/python/pdb# python pdbtest.py
--Return--
&gt; /usr/lib/python2.3/pdb.py(992)set_trace()-&gt;None
-&gt; Pdb().set_trace()              # 从跟踪点开始执行
(Pdb) n                           # n 读入下一行代码
&gt; /root/python/pdb/pdbtest.py(6) ()
-&gt; b = &quot;bbb&quot;
(Pdb) n
&gt; /root/python/pdb/pdbtest.py(7) ()
-&gt; c = &quot;ccc&quot;
(Pdb) p b                         # p 打印变量值
'bbb'
(Pdb) l                           # l 显示当前执行位置
  2
  3     import pdb
  4     a = &quot;aaa&quot;
  5     pdb.set_trace()
  6     b = &quot;bbb&quot;
  7  -&gt; c = &quot;ccc&quot;
  8     final = a + b + c
  9     print final
 10
[EOF]
(Pdb) n                          
&gt; /root/python/pdb/pdbtest.py(8) ()
-&gt; final = a + b + c
(Pdb) n                           # 如果命令和上次的一样，也可直接按回车，不用输入'n' 
&gt; /root/python/pdb/pdbtest.py(9) ()
-&gt; print final
(Pdb) n
aaabbbccc
--Return--
&gt; /root/python/pdb/pdbtest.py(9) ()-&gt;None
-&gt; print final
(Pdb) p a,b,c,final
('aaa', 'bbb', 'ccc', 'aaabbbccc')
(Pdb)
('aaa', 'bbb', 'ccc', 'aaabbbccc')
(Pdb) n
localhost:~/python/pdb#           # 返回shell       
</pre><p>pdb还有很多命令，用help命令就可以列出所有的pdb命令，用help p可以查询p命令的说明。</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2881117"></a>Chapter 12. HOW-TO</h2></div></div><div></div></div><p>本章内容记录Python的一些小技巧小知识。来源是网上摘录或自己学习所得。</p><div class="itemizedlist"><ul type="disc"><li><p>如何判断操作系统类型</p><pre class="screen">
import sys
print sys.platform
print sys.version
</pre></li><li><p>显示和修改python的Module搜索路径</p><pre class="screen">
&gt;&gt;&gt; import sys
&gt;&gt;&gt; print sys.path
['', '/usr/lib/python23.zip', '/usr/lib/python2.3', '/usr/lib/python2.3/plat-linux2',
 '/usr/lib/python2.3/lib-tk', '/usr/lib/python2.3/lib-dynload', '/usr/local/lib/python2.3/site-packages',
 '/usr/lib/python2.3/site-packages']
&gt;&gt;&gt; sys.path.append('/usr/lib/mypath')
&gt;&gt;&gt; print sys.path
['', '/usr/lib/python23.zip', '/usr/lib/python2.3', '/usr/lib/python2.3/plat-linux2',
'/usr/lib/python2.3/lib-tk', '/usr/lib/python2.3/lib-dynload', '/usr/local/lib/python2.3/site-packages',
 '/usr/lib/python2.3/site-packages', '/usr/lib/mypath']
</pre></li><li><p>把列表转换成字符串</p><pre class="screen">
&gt;&gt;&gt; t=['a','b','c']
&gt;&gt;&gt; print t
['a', 'b', 'c']
&gt;&gt;&gt; import string
&gt;&gt;&gt; print string.join(t)
a b c
</pre></li><li><p>运行系统程序</p><pre class="screen">
&gt;&gt;&gt;import os
&gt;&gt;&gt;os.system('ls')            #用os.system()可执行系统命令
&gt;&gt;&gt;exec &quot;os.system('ls')&quot;     #用exec可执行字符串中的命令，两个命令的效果一样。
</pre><p>以上两个命令的输出都是直接显示在屏幕上，不能保存到变量中，如果我们要把输出保存起来，可用os.pope\
n()函数。</p><pre class="screen">
&gt;&gt;&gt;cmd = '/usr/bin/mkntpwd %s' % password
&gt;&gt;&gt;handler = os.popen(cmd,'r')
&gt;&gt;&gt;passwordString=handler.read()   #passwordString为mkntpwd程序的输出结果
</pre><p>使用commands模块也可以获取程序的输出，它包含一些基于os.popen()的封装函数，使我们能更方便地获取运行系统命令和获取命令的输出，但该模块只在Unix系统下有效，不能用于Windows平台。</p><pre class="screen">
&gt;&gt;&gt; import commands
&gt;&gt;&gt; status,output = commands.getstatusoutput('ls -l')
&gt;&gt;&gt; print output
总计 96564
-rw-r--r--  1 root     root         4459 2005-12-01 10:23 2005.sxw
-rw-r--r--  1 root     root        27511 2006-04-12 16:54 20060412_user.ods
-rw-r--r--  1 root     root       202258 2006-01-06 16:48 2006风景-1月.jpg
...
&gt;&gt;&gt; print status
0
</pre><p>在Python2.4中引入一个新的模块叫subprocess，用于取代os.system、os.spawn*、os.popen*、popen2.*、commands.*。</p></li><li><p>编码转换</p><pre class="screen">
#!/usr/bin/python
#-*-coding:utf-8 -*-

a=u&quot;测试&quot;
b=a.encode('gb2312')
print a
print b
</pre></li><li><p>交换两个变量</p><pre class="screen">
&gt;&gt;&gt; a,b = 1,2
&gt;&gt;&gt; a,b
(1, 2)
&gt;&gt;&gt; a,b = b,a
&gt;&gt;&gt; a,b
(2, 1)
&gt;&gt;&gt; a
2
&gt;&gt;&gt; b
1
</pre></li><li><p>测试数据类型</p><pre class="screen">
&gt;&gt;&gt; a=123
&gt;&gt;&gt; b='test'
&gt;&gt;&gt; a
123
&gt;&gt;&gt; b
'test'
&gt;&gt;&gt; isinstance(a,int)
True
&gt;&gt;&gt; isinstance(a,str)
False
&gt;&gt;&gt; isinstance(b,int)
False
&gt;&gt;&gt; isinstance(b,str)
True
</pre></li><li><p>用in判断是否包含子字符串</p><pre class="screen">
&gt;&gt;&gt; a='this is my test'
&gt;&gt;&gt; 'is' in a
True
&gt;&gt;&gt; 'mm' in a
False
</pre></li><li><p>__iter__迭代器</p><pre class="screen">
&gt;&gt;&gt; a = &quot;iterator&quot;
&gt;&gt;&gt; t = iter(a)
&gt;&gt;&gt; t.next()
'i'
&gt;&gt;&gt; t.next()
't'
&gt;&gt;&gt; t.next()
'e'
&gt;&gt;&gt; t.next()
'r'
&gt;&gt;&gt; t.next()
'a'
&gt;&gt;&gt; t.next()
't'
&gt;&gt;&gt; t.next()
'o'
&gt;&gt;&gt; t.next()
'r'
&gt;&gt;&gt; t.next()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in  
StopIteration
</pre><p>自已写一个迭代器类</p><pre class="screen">
&gt;&gt;&gt; class reverse:
...     def __init__(self,data):
...             self.data=data
...             self.index=len(data)
...     def __iter__(self):
...             return self
...     def next(self):
...             if self.index == 0:
...                     raise StopIteration
...             self.index = self.index - 1
...             return self.data[self.index]
...
&gt;&gt;&gt; for char in reverse('iterator'):
...     print char
...
r
o
t
a
r
e
t
i
&gt;&gt;&gt;
</pre></li><li><p>通过getattr可以得到一个在运行时才知道具体函数名的对象的引用，能增强我们程序的灵活性。</p><pre class="screen">
&gt;&gt;&gt; li=['a','b']
&gt;&gt;&gt; getattr(li,'append')
&gt;&gt;&gt; getattr(li,'append')('c')          #相当于li.append('c')
&gt;&gt;&gt; li
['a', 'b', 'c']
&gt;&gt;&gt; handler=getattr(li,'append',None)
&gt;&gt;&gt; handler
&lt;built-in method append of list object at 0xb7d4a52c&gt;
&gt;&gt;&gt; handler('cc')                      #相当于li.append('cc')
&gt;&gt;&gt; li
['a','b','c','cc']
&gt;&gt;&gt;result = handler('bb')
&gt;&gt;&gt;li
['a','b','c','cc','bb']
&gt;&gt;&gt;print result
None
</pre><p>编程示例：</p><pre class="screen">
import statsout

def output(data, format=&quot;text&quot;):                              
    output_function = getattr(statsout, &quot;output_%s&quot; % format) 
    return output_function(data)                              
</pre><p>以上代码表示，output函数接收一个data参数和format参数，根据format参数的值，从statsout模块中取出output_text函数运行，data参数通过output_function(data)传递给了statsout模块中的output_text函数。format取不同值可从statsout模块中取出不同的函数运行（output_xxxx）。也就是说我们要运行的函数是在程序运行后才确定的。这样我们可把不同的函数以output_xxx形式命名放在statout模块中，通过以上程序可动态调用各种函数。</p></li><li><p>hasattr用于确定一个对象是否具有某个属性。</p><pre class="screen">
语法：
 hasattr(object, name) -&gt; bool
判断object中是否有name属性，返回一个布尔值。
</pre></li><li><p>拆分序列</p><pre class="screen">
&gt;&gt;&gt; a=[c for c in 'abcdefg']
&gt;&gt;&gt; a
['a', 'b', 'c', 'd', 'e', 'f', 'g']
&gt;&gt;&gt;
</pre><p>按if条件拆分序列</p><pre class="screen">
&gt;&gt;&gt; a=[c for c in '123456' if int(c)&lt;3]      如果if的条件为真，则执行for循环
&gt;&gt;&gt; a
['1', '2']
&gt;&gt;&gt; a=[c for c in '123456' if int(c)&gt;3]      如果if的条件为假，则不执行for循环
&gt;&gt;&gt; a
['4', '5', '6']
</pre></li><li><p>__dict__记录模块或类中所有对象的信息，它以字典{name:object}的形式记录这些信息，如果wikiaction是一个模块，则可以这样显示：</p><pre class="screen">
&gt;&gt;&gt;import wikiaction
&gt;&gt;&gt;print wikiaction.__dict__
{'do_test': &lt;function do_test at 0xb7c10534&gt;, 'do_diff': &lt;function do_diff at 0xb7c0ef0c&gt;, 'do_refresh': &lt;fun
ction do_refresh at 0xb7c1025c&gt;, 'do_userform': &lt;function do_userform at 0xb7c103e4&gt;, 'getHandler': &lt;function
 getHandler at 0xb7c105a4&gt;, 'do_raw': &lt;function do_raw at 0xb7c10454&gt;, 'do_chart': &lt;function do_chart at 0xb7
c104c4&gt;, 're': &lt;module 're' from '/usr/lib/python2.3/re.pyc'&gt;, 'pysupport': &lt;module 'MoinMoin.util.pysupport'
 from '/usr/lib/python2.3/site-packages/MoinMoin/util/pysupport.pyc'&gt;, 'config': &lt;module 'MoinMoin.config' fr
om '/usr/lib/python2.3/site-packages/MoinMoin/config.pyc'&gt;}
</pre></li><li><p>'and'的特殊用法</p><pre class="screen">
&gt;&gt;&gt; 'a' and 'b'         #如果两个都为真值，返回最后一个真值
'b'
&gt;&gt;&gt; 'b' and 'a'         #同上
'a'
&gt;&gt;&gt; 'a' and 'b' and 'c' #同上
'c'
&gt;&gt;&gt; '' and 'a'          #如果有假值，则返回假值
''
&gt;&gt;&gt; 'a' and '' and 'c'  #同上
''
&gt;&gt;&gt; '' and 0            #如果两个都为假值，返回第一个假值
''
&gt;&gt;&gt; 0 and ''            #同上
0
</pre></li><li><p>'or'的的特殊用法</p><pre class="screen">
&gt;&gt;&gt; 'a' or 'b'          #如果有一个为真值，则返回第一个真值
'a'
&gt;&gt;&gt; 'b' or 'a'          #同上
'b'
&gt;&gt;&gt; 'a' or 'b' or ''    #同上
'a'
&gt;&gt;&gt; 0 and '' and {}     #如果所有都是假值，则返回第一个假值
0
&gt;&gt;&gt; {} and '' and {}    #同上
{}

</pre></li><li><p>lambda匿名函数的用法</p><pre class="screen">
&gt;&gt;&gt; a=lambda c:c*2
&gt;&gt;&gt; a
&lt;function &lt;lambda&gt; at 0xb7dd710c&gt;
&gt;&gt;&gt; a(2)
4
&gt;&gt;&gt; a(5)
10
</pre></li></ul></div></div></div>

<DIV style="DISPLAY: none">
 <script src='http://s42.cnzz.com/stat.php?id=423754&web_id=423754&show=pic' language='JavaScript' charset='gb2312'>
</script>
</DIV>
</body></html>
